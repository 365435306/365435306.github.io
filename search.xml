<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端开发规范vue版</title>
    <url>/posts/3007902684.html</url>
    <content><![CDATA[<h1 id="前端-JS-项目开发规范"><a href="#前端-JS-项目开发规范" class="headerlink" title="前端 JS 项目开发规范"></a>前端 JS 项目开发规范</h1><p>规范的目的是为了编写高质量的代码，让你的团队成员每天得心情都是愉悦的，大家在一起是快乐的。</p>
<p>引自《阿里规约》的开头片段：</p>
<p>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</p>
<h2 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h2><h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><h4 id="1-1-1-项目命名"><a href="#1-1-1-项目命名" class="headerlink" title="1.1.1 项目命名"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。</p>
<p>正例：mall-management-system</p>
<p>反例：mall_management-system / mallManagementSystem</p>
<h4 id="1-1-2-目录命名"><a href="#1-1-2-目录命名" class="headerlink" title="1.1.2 目录命名"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数</p>
<p>正例： scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</p>
<p>反例： script / style / demo_scripts / demoStyles / imgs / docs</p>
<p>【特殊】VUE 的项目中的 components 中的组件目录，使用驼峰命名 CamelCase</p>
<p>反例： head-search / page-loading </p>
<p>正例： HeadSearch / PageLoading</p>
<p>【特殊】VUE 的项目中的除 components 组件目录外的所有目录使用 lowerCamelCase 命名<br>反例： page-one / shopping-car / user-management</p>
<p>正例： shoppingCar / userManagement</p>
<h4 id="1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用lowerCamelCase 命名</p>
<p>反例： render-dom.js / signup.css / index.html / company-logo.png</p>
<p>正例： renderDom.js / userManagement.css</p>
<h4 id="1-1-4-命名严谨性"><a href="#1-1-4-命名严谨性" class="headerlink" title="1.1.4 命名严谨性"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用</p>
<p>正例：henan / luoyang / rmb 等国际通用的名称，可视同英文。</p>
<p>反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</p>
<p>杜绝完全不规范的缩写，避免望文不知义：</p>
<p>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</p>
<h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><h4 id="1-2-1-HTML-类型"><a href="#1-2-1-HTML-类型" class="headerlink" title="1.2.1 HTML 类型"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型申明： .<br>（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p>
<p>规定字符编码<br>IE 兼容模式<br>规定字符编码<br>doctype 大写<br>正例：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Page title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;img src=&quot;images/companyLogo.png&quot; alt=&quot;Company&quot; /&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><h4 id="1-2-2-缩进"><a href="#1-2-2-缩进" class="headerlink" title="1.2.2 缩进"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）</p>
<p>嵌套的节点应该缩进。</p>
<h4 id="1-2-3-分块注释"><a href="#1-2-3-分块注释" class="headerlink" title="1.2.3 分块注释"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p>
<pre><code>&lt;!-- 工具栏 --&gt;
&lt;div &gt;&lt;/div&gt;
&lt;!-- 表格 --&gt;
&lt;table &gt;&lt;/table&gt;</code></pre><h4 id="1-2-4-语义化标签"><a href="#1-2-4-语义化标签" class="headerlink" title="1.2.4 语义化标签"></a>1.2.4 语义化标签</h4><p>HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签</p>
<p>正例</p>
<pre><code>&lt;header&gt;&lt;/header&gt;
&lt;footer&gt;&lt;/footer&gt;</code></pre><p>反例</p>
<pre><code>&lt;div&gt;
  &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre><h3 id="三-CSS-规范"><a href="#三-CSS-规范" class="headerlink" title="(三) CSS 规范"></a>(三) CSS 规范</h3><h4 id="1-3-1-命名"><a href="#1-3-1-命名" class="headerlink" title="1.3.1 命名"></a>1.3.1 命名</h4><p>类名使用小写字母，以中划线分隔<br>id 采用大驼峰式命名 </p>
<p>scss 中的变量、函数、混合、placeholder 采用小驼峰式命名</p>
<p>ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</p>
<p>不推荐：</p>
<pre><code>.heavy {
  font-weight: 800;
}

.red {
  color: red;
}</code></pre><p>推荐:</p>
<pre><code>.fw-800 {
  font-weight: 800;
}

.important {
  color: red;
}</code></pre><h4 id="1-3-2-选择器"><a href="#1-3-2-选择器" class="headerlink" title="1.3.2 选择器"></a>1.3.2 选择器</h4><p>1)css 选择器中避免使用标签名<br>从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。</p>
<p>2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。</p>
<p>不推荐:</p>
<pre><code>.content .title {
  font-size: 2rem;
}</code></pre><p>推荐:</p>
<pre><code>.content &gt; .title {
  font-size: 2rem;
}</code></pre><h4 id="1-3-3-尽量使用缩写属性"><a href="#1-3-3-尽量使用缩写属性" class="headerlink" title="1.3.3 尽量使用缩写属性"></a>1.3.3 尽量使用缩写属性</h4><p>不推荐：</p>
<pre><code>border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;</code></pre><p>推荐：</p>
<pre><code>border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;</code></pre><h4 id="1-3-4-每个选择器及属性独占一行"><a href="#1-3-4-每个选择器及属性独占一行" class="headerlink" title="1.3.4 每个选择器及属性独占一行"></a>1.3.4 每个选择器及属性独占一行</h4><p>不推荐：</p>
<pre><code>button{
  width:100px;height:50px;color:#fff;background:#00a0e9;
}</code></pre><p>推荐：</p>
<pre><code>button{
  width:100px;
  height:50px;
  color:#fff;
  background:#00a0e9;
}</code></pre><h4 id="1-3-5-省略0后面的单位"><a href="#1-3-5-省略0后面的单位" class="headerlink" title="1.3.5 省略0后面的单位"></a>1.3.5 省略0后面的单位</h4><p>不推荐：</p>
<pre><code>div{
  padding-bottom: 0px;
  margin: 0em;
}</code></pre><p>推荐：</p>
<pre><code>div{
  padding-bottom: 0;
  margin: 0;
}</code></pre><h4 id="1-3-6-避免使用ID选择器及全局标签选择器防止污染全局样式"><a href="#1-3-6-避免使用ID选择器及全局标签选择器防止污染全局样式" class="headerlink" title="1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式"></a>1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</h4><p>不推荐：</p>
<pre><code>#header{
  padding-bottom: 0px;
  margin: 0em;
}</code></pre><p>推荐：</p>
<pre><code>.header{
  padding-bottom: 0;
  margin: 0;
}</code></pre><h3 id="四-SCSS-规范"><a href="#四-SCSS-规范" class="headerlink" title="(四) SCSS 规范"></a>(四) SCSS 规范</h3><h4 id="1-4-1-代码组织"><a href="#1-4-1-代码组织" class="headerlink" title="1.4.1 代码组织"></a>1.4.1 代码组织</h4><p>1)将公共scss文件放置在assets/styles/common文件夹<br>例:// color.scss,common.scss</p>
<p>2)按以下顺序组织<br>1、@import;<br>2、变量声明;<br>3、样式声明;</p>
<pre><code>@import &quot;mixins/size.scss&quot;;

@default-text-color: #333;

.page {
  width: 960px;
  margin: 0 auto;
}</code></pre><h4 id="1-4-2-避免嵌套层级过多"><a href="#1-4-2-避免嵌套层级过多" class="headerlink" title="1.4.2 避免嵌套层级过多"></a>1.4.2 避免嵌套层级过多</h4><p>将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。<br>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现</p>
<p>不推荐：</p>
<pre><code>.main{
  .title{
    .name{
      color:#fff
    }
  }
}</code></pre><p>推荐：</p>
<pre><code>.main-title{
  .name{
      color:#fff
  }
}</code></pre><h3 id="五-Javascript-规范"><a href="#五-Javascript-规范" class="headerlink" title="(五) Javascript 规范"></a>(五) Javascript 规范</h3><h4 id="1-5-1-命名"><a href="#1-5-1-命名" class="headerlink" title="1.5.1 命名"></a>1.5.1 命名</h4><p>1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束<br>反例： <em>name / name</em> / name$</p>
<p>2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>正例： localValue / getHttpMessage() / inputUserId</p>
<p><em>其中 method 方法命名必须是 动词 或者 动词+名词 形式</em></p>
<p>正例：saveShopCarData /openShopCarInfoDialog</p>
<p>反例：save / open / show / go</p>
<p><em>特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）</em></p>
<p>add / edit / delete / detail / get</p>
<p>附： 函数方法常用的动词:</p>
<pre><code>get 获取/set 设置,
add 增加/remove 删除
create 创建/destory 移除
start 启动/stop 停止
open 打开/close 关闭,
read 读取/write 写入
load 载入/save 保存,
create 创建/destroy 销毁
begin 开始/end 结束,
backup 备份/restore 恢复
import 导入/export 导出,
split 分割/merge 合并
inject 注入/extract 提取,
attach 附着/detach 脱离
bind 绑定/separate 分离,
view 查看/browse 浏览
edit 编辑/modify 修改,
select 选取/mark 标记
copy 复制/paste 粘贴,
undo 撤销/redo 重做
insert 插入/delete 移除,
add 加入/append 添加
clean 清理/clear 清除,
index 索引/sort 排序
find 查找/search 搜索,
increase 增加/decrease 减少
play 播放/pause 暂停,
launch 启动/run 运行
compile 编译/execute 执行,
debug 调试/trace 跟踪
observe 观察/listen 监听,
build 构建/publish 发布
input 输入/output 输出,
encode 编码/decode 解码
encrypt 加密/decrypt 解密,
compress 压缩/decompress 解压缩
pack 打包/unpack 解包,
parse 解析/emit 生成
connect 连接/disconnect 断开,
send 发送/receive 接收
download 下载/upload 上传,
refresh 刷新/synchronize 同步
update 更新/revert 复原,
lock 锁定/unlock 解锁
check out 签出/check in 签入,
submit 提交/commit 交付
push 推/pull 拉,
expand 展开/collapse 折叠
begin 起始/end 结束,
start 开始/finish 完成
enter 进入/exit 退出,
abort 放弃/quit 离开
obsolete 废弃/depreciate 废旧,
collect 收集/aggregate 聚集</code></pre><p>3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>正例： MAX_STOCK_COUNT</p>
<p>反例： MAX_COUNT</p>
<h4 id="1-5-2-代码格式"><a href="#1-5-2-代码格式" class="headerlink" title="1.5.2 代码格式"></a>1.5.2 代码格式</h4><p>1) 使用 2 个空格进行缩进<br>正例：</p>
<pre><code>if (x &lt; y) {
  x += 10;
} else {
  x += 1;
}</code></pre><p>2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：任何情形，没有必要插入多个空行进行隔开。</p>
<h4 id="1-5-3-字符串"><a href="#1-5-3-字符串" class="headerlink" title="1.5.3 字符串"></a>1.5.3 字符串</h4><p>统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：</p>
<p>正例:</p>
<pre><code>let str = &apos;foo&apos;;
let testDiv = &apos;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&apos;;</code></pre><p>反例:</p>
<pre><code>let str = &apos;foo&apos;;
let testDiv = &quot;&lt;div id=&apos;test&apos;&gt;&lt;/div&gt;&quot;;</code></pre><h4 id="1-5-4-对象声明"><a href="#1-5-4-对象声明" class="headerlink" title="1.5.4 对象声明"></a>1.5.4 对象声明</h4><p>1)使用字面值创建对象</p>
<pre><code>正例： let user = {};

反例： let user = new Object();</code></pre><p>2) 使用字面量来代替对象构造器<br>正例：</p>
<pre><code>var user = {
  age: 0,
  name: 1,
  city: 3
};</code></pre><p>反例：</p>
<pre><code>var user = new Object();
user.age = 0;
user.name = 0;
user.city = 0;</code></pre><h4 id="1-5-5-使用-ES6-7"><a href="#1-5-5-使用-ES6-7" class="headerlink" title="1.5.5 使用 ES6,7"></a>1.5.5 使用 ES6,7</h4><p>必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p>
<p>必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for…of 等等</p>
<h4 id="1-5-6-括号"><a href="#1-5-6-括号" class="headerlink" title="1.5.6 括号"></a>1.5.6 括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>
<p>正例：</p>
<pre><code>if (condition) {
  doSomething();
}</code></pre><p>反例：</p>
<pre><code>if (condition) doSomething();</code></pre><h4 id="1-5-7-undefined-判断"><a href="#1-5-7-undefined-判断" class="headerlink" title="1.5.7 undefined 判断"></a>1.5.7 undefined 判断</h4><p>永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。</p>
<p>正例：</p>
<pre><code>if (typeof person === &apos;undefined&apos;) {
    ...
}</code></pre><p>反例：</p>
<pre><code>if (person === undefined) {
    ...
}</code></pre><h4 id="1-5-8-条件判断和循环最多三层"><a href="#1-5-8-条件判断和循环最多三层" class="headerlink" title="1.5.8 条件判断和循环最多三层"></a>1.5.8 条件判断和循环最多三层</h4><p>条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</p>
<h4 id="1-5-9-this-的转换命名"><a href="#1-5-9-this-的转换命名" class="headerlink" title="1.5.9 this 的转换命名"></a>1.5.9 this 的转换命名</h4><p>对上下文 this 的引用使用’that’来命名</p>
<h4 id="1-5-10-慎用-console-log"><a href="#1-5-10-慎用-console-log" class="headerlink" title="1.5.10 慎用 console.log"></a>1.5.10 慎用 console.log</h4><p>因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能。使用结束后记得删除。</p>
<h2 id="二、Vue-项目规范"><a href="#二、Vue-项目规范" class="headerlink" title="二、Vue 项目规范"></a>二、Vue 项目规范</h2><h3 id="一-Vue-编码基础"><a href="#一-Vue-编码基础" class="headerlink" title="(一) Vue 编码基础"></a>(一) Vue 编码基础</h3><p>vue 项目规范以 Vue 官方规范 （<a href="https://cn.vuejs.org/v2/style-guide/）" target="_blank" rel="noopener">https://cn.vuejs.org/v2/style-guide/）</a> 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p>
<p>请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</p>
<h4 id="2-1-1-组件规范"><a href="#2-1-1-组件规范" class="headerlink" title="2.1.1. 组件规范"></a>2.1.1. 组件规范</h4><p>1) 组件名为多个单词。<br>组件名应该始终是多个单词组成（大于等于 2），且命名规范为PascalCase格式，大驼峰拼写。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p>
<pre><code>正例：

export default {
  name: &apos;TodoItem&apos;
  // ...
};
反例：

export default {
  name: &apos;Todo&apos;,
  // ...
}
export default {
  name: &apos;todo-item&apos;,
  // ...
}</code></pre><p>2) 组件文件名为 PascalCase 格式</p>
<pre><code>正例：

components/
|- MyComponent.vue

反例：

components/
|- myComponent.vue
|- my-component.vue</code></pre><p>3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。</p>
<pre><code>正例：

components/
|- MyButton.vue
|- VueTable.vue
|- Icon.vue

反例：

components/
|- base-button.vue
|- base-table.vue
|- base-icon.vue</code></pre><p>4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</p>
<pre><code>正例：

components/
|- TodoList.vue
|- TodoItem.vue
|- TodoButton.vue
|- UProfOpts.vue （使用了缩写）

反例：

components/
|- todo-list.vue
|- todo-list-item.vue
|- todo-list-item-button.vue
|- user-profile-options.vue （完整单词）</code></pre><p>5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。</p>
<pre><code>正例：

&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;
&lt;MyComponent /&gt;
&lt;Row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/Row&gt;
反例：

&lt;my-component /&gt; &lt;row&gt;&lt;table :column=&quot;data&quot;/&gt;&lt;/row&gt;</code></pre><p>6) 组件的 data 必须是一个函数<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。</p>
<p>正例：</p>
<pre><code>export default {
  data () {
    return {
      name: &apos;jack&apos;
    }
  }
}</code></pre><p>反例：</p>
<pre><code>export default {
  data: {
    name: &apos;jack&apos;
  }
}</code></pre><p>7) Prop 定义应该尽量详细<br>必须使用 camelCase 驼峰命名<br>必须指定类型<br>必须加上注释，表明其含义<br>必须加上 required 或者 default，两者二选其一<br>如果有业务需要，必须加上 validator 验证<br>正例：</p>
<pre><code>props: {
  // 组件状态，用于控制组件的颜色
  status: {
    type: String,
    required: true,
    validator: function (value) {
      return [
        &apos;succ&apos;,
        &apos;info&apos;,
        &apos;error&apos;
      ].indexOf(value) !== -1
    }
  },
    // 用户级别，用于显示皇冠个数
  userLevel：{
      type: String,
      required: true
  }
}</code></pre><p>8) 为组件样式设置作用域<br>正例：</p>
<pre><code>&lt;template&gt;
  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;!-- 使用 `scoped` 特性 --&gt;
&lt;style scoped&gt;
  .btn-close {
    background-color: red;
  }
&lt;/style&gt;</code></pre><p>反例：</p>
<pre><code>&lt;template&gt;
  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;
&lt;!-- 没有使用 `scoped` 特性 --&gt;
&lt;style&gt;
  .btn-close {
    background-color: red;
  }
&lt;/style&gt;</code></pre><p>9) 如果特性元素较多，应该主动换行。<br>正例：</p>
<pre><code>&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;
    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;
    foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;
/&gt;</code></pre><p>反例：</p>
<pre><code>&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;</code></pre><h4 id="2-1-2-模板中使用简单的表达式"><a href="#2-1-2-模板中使用简单的表达式" class="headerlink" title="2.1.2. 模板中使用简单的表达式"></a>2.1.2. 模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p>
<p>正例：</p>
<pre><code>&lt;template&gt;
  &lt;p&gt;{{ normalizedFullName }}&lt;/p&gt;
&lt;/template&gt;

// 复杂表达式已经移入一个计算属性
computed: {
  normalizedFullName: function () {
    return this.fullName.split(&apos; &apos;).map(function (word) {
      return word[0].toUpperCase() + word.slice(1)
    }).join(&apos; &apos;)
  }
}</code></pre><p>反例：</p>
<pre><code>&lt;template&gt;
  &lt;p&gt;
      {{
              fullName.split(' ').map(function (word) {
                return word[0].toUpperCase() + word.slice(1)
              }).join(' ')
            }}
  &lt;/p&gt;
&lt;/template&gt;</code></pre><h4 id="2-1-3-指令都使用缩写形式"><a href="#2-1-3-指令都使用缩写形式" class="headerlink" title="2.1.3 指令都使用缩写形式"></a>2.1.3 指令都使用缩写形式</h4><p>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</p>
<pre><code>正例：

&lt;input
  @input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;
&gt;
反例：

&lt;input
  v-on:input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;</code></pre><h4 id="2-1-4-标签顺序保持一致"><a href="#2-1-4-标签顺序保持一致" class="headerlink" title="2.1.4 标签顺序保持一致"></a>2.1.4 标签顺序保持一致</h4><p>单文件组件应该总是让标签顺序保持为 `</p>
<pre><code>正例：

&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;...&lt;/script&gt;
&lt;style&gt;...&lt;/style&gt;
反例：

&lt;template&gt;...&lt;/template&gt;
&lt;style&gt;...&lt;/style&gt;
&lt;script&gt;...&lt;/script&gt;</code></pre><h4 id="2-1-5-必须为-v-for-设置键值-key"><a href="#2-1-5-必须为-v-for-设置键值-key" class="headerlink" title="2.1.5 必须为 v-for 设置键值 key"></a>2.1.5 必须为 v-for 设置键值 key</h4><h4 id="2-1-6-v-show-与-v-if-选择"><a href="#2-1-6-v-show-与-v-if-选择" class="headerlink" title="2.1.6 v-show 与 v-if 选择"></a>2.1.6 v-show 与 v-if 选择</h4><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p>
<h4 id="2-1-7-script-标签内部结构顺序"><a href="#2-1-7-script-标签内部结构顺序" class="headerlink" title="2.1.7 script 标签内部结构顺序"></a>2.1.7 script 标签内部结构顺序</h4><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p>
<h4 id="2-1-8-Vue-Router-规范"><a href="#2-1-8-Vue-Router-规范" class="headerlink" title="2.1.8 Vue Router 规范"></a>2.1.8 Vue Router 规范</h4><p>1) 页面跳转数据传递使用路由参数<br>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</p>
<p>正例：</p>
<pre><code>let id = &apos; 123&apos;;
this.$router.push({ name: &apos;userCenter&apos;, query: { id: id } });</code></pre><p>2) 使用路由懒加载（延迟加载）机制</p>
<pre><code>{
  path: &apos;/uploadAttachment&apos;,
  name: &apos;uploadAttachment&apos;,
  meta: {
    title: &apos;上传附件&apos;
  },
  component: () =&gt; import(&apos;@/view/components/uploadAttachment/index.vue&apos;)
},</code></pre><p>3) router 中的命名规范<br>path、childrenPoints 命名规范采用kebab-case命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是kebab-case，这样很方便找到对应的文件）</p>
<p>name 命名规范采用KebabCase命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）</p>
<pre><code>// 动态加载
export const reload = [
  {
    path: &apos;/reload&apos;,
    name: &apos;reload&apos;,
    component: Main,
    meta: {
      title: &apos;动态加载&apos;,
      icon: &apos;icon iconfont&apos;
    },

    children: [
      {
        path: &apos;/reload/smart-reload-list&apos;,
        name: &apos;SmartReloadList&apos;,
        meta: {
          title: &apos;SmartReload&apos;,
          childrenPoints: [
            {
              title: &apos;查询&apos;,
              name: &apos;smart-reload-search&apos;
            },
            {
              title: &apos;执行reload&apos;,
              name: &apos;smart-reload-update&apos;
            },
            {
              title: &apos;查看执行结果&apos;,
              name: &apos;smart-reload-result&apos;
            }
          ]
        },
        component: () =&gt;
          import(&apos;@/views/reload/smart-reload/smart-reload-list.vue&apos;)
      }
    ]
  }
];</code></pre><p>4) router 中的 path 命名规范<br>path除了采用kebab-case命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例</p>
<p>目的：</p>
<p>经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件</p>
<pre><code>{
  path: &apos;/file&apos;,
  name: &apos;File&apos;,
  component: Main,
  meta: {
    title: &apos;文件服务&apos;,
    icon: &apos;ios-cloud-upload&apos;
  },
  children: [
    {
      path: &apos;/file/file-list&apos;,
      name: &apos;FileList&apos;,
      component: () =&gt; import(&apos;@/views/file/file-list.vue&apos;)
    },
    {
      path: &apos;/file/file-add&apos;,
      name: &apos;FileAdd&apos;,
      component: () =&gt; import(&apos;@/views/file/file-add.vue&apos;)
    },
    {
      path: &apos;/file/file-update&apos;,
      name: &apos;FileUpdate&apos;,
      component: () =&gt; import(&apos;@/views/file/file-update.vue&apos;)
    }
  ]
}</code></pre><h3 id="二-Vue-项目目录规范"><a href="#二-Vue-项目目录规范" class="headerlink" title="(二) Vue 项目目录规范"></a>(二) Vue 项目目录规范</h3><h4 id="2-2-1-基础"><a href="#2-2-1-基础" class="headerlink" title="2.2.1 基础"></a>2.2.1 基础</h4><p>vue 项目中的所有命名一定要与后端命名统一。</p>
<p>比如权限：后端 permission, 前端无论 router , store, api 等都必须使用 permission 单词！</p>
<h4 id="2-2-2-使用-Vue-cli-脚手架"><a href="#2-2-2-使用-Vue-cli-脚手架" class="headerlink" title="2.2.2 使用 Vue-cli 脚手架"></a>2.2.2 使用 Vue-cli 脚手架</h4><p>使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</p>
<h4 id="2-2-3-目录说明"><a href="#2-2-3-目录说明" class="headerlink" title="2.2.3 目录说明"></a>2.2.3 目录说明</h4><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 camelCase 命名。</p>
<pre><code>src                               源码目录
|-- api                              所有api接口
|-- assets                           静态资源，images, icons, styles等
|-- components                       公用组件
|-- config                           配置信息
|-- constants                        常量信息，项目所有Enum, 全局常量等
|-- directives                       自定义指令
|-- filters                          过滤器，全局工具
|-- datas                            模拟数据，临时存放
|-- lib                              外部引用的插件存放及修改文件
|-- mock                             模拟接口，临时存放
|-- plugins                          插件，全局使用
|-- router                           路由，统一管理
|-- store                            vuex, 统一管理
|-- themes                           自定义样式主题
|-- views                            视图目录
|   |-- role                             role模块名
|   |-- |-- roleList.vue                    role列表页面
|   |-- |-- roleAdd.vue                     role新建页面
|   |-- |-- roleUpdate.vue                  role更新页面
|   |-- |-- index.less                      role模块样式
|   |-- |-- components                      role模块通用组件文件夹
|   |-- employee                         employee模块</code></pre><p>1) api 目录<br>文件、变量命名要与后端保持一致。<br>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。<br>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。<br>对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。<br>正例：</p>
<p>后端 url： EmployeeController.java</p>
<pre><code>/employee/add
/employee/delete/{id}
/employee/update</code></pre><p>前端： employee.js</p>
<pre><code>// 添加员工
addEmployee: (data) =&gt; {
  return postAxios(&apos;/employee/add&apos;, data)
},
// 更新员工信息
updateEmployee: (data) =&gt; {
  return postAxios(&apos;/employee/update&apos;, data)
},
  // 删除员工
deleteEmployee: (employeeId) =&gt; {
  return postAxios(&apos;/employee/delete/&apos; + employeeId)</code></pre><p>   },</p>
<p>2) assets 目录<br>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 lowerCamelCase</p>
<pre><code>|assets
|-- icons
|-- images
|   |-- backgroundColor.png
|   |-- uploadHeader.png
|-- styles</code></pre><p>3) components 目录<br>此目录应按照组件进行目录划分，目录命名为 lowerCamelCase，组件命名规则也为 lowerCamelCase</p>
<pre><code>|components
|-- errorLog
|   |-- index.vue
|   |-- index.less
|-- markdownEditor
|   |-- index.vue
|   |-- index.js</code></pre><p>4) constants 目录<br>此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(<a href="https://www.npmjs.com/package/vue-enum" target="_blank" rel="noopener">https://www.npmjs.com/package/vue-enum</a>)</p>
<pre><code>目录结构：

|constants
|-- index.js
|-- role.js
|-- employee.js
例子： employee.js

export const EMPLOYEE_STATUS = {
  NORMAL: {
    value: 1,
    desc: &apos;正常&apos;
  },
  DISABLED: {
    value: 1,
    desc: &apos;禁用&apos;
  },
  DELETED: {
    value: 2,
    desc: &apos;已删除&apos;
  }
};

export const EMPLOYEE_ACCOUNT_TYPE = {
  QQ: {
    value: 1,
    desc: &apos;QQ登录&apos;
  },
  WECHAT: {
    value: 2,
    desc: &apos;微信登录&apos;
  },
  DINGDING: {
    value: 3,
    desc: &apos;钉钉登录&apos;
  },
  USERNAME: {
    value: 4,
    desc: &apos;用户名密码登录&apos;
  }
};

export default {
  EMPLOYEE_STATUS,
  EMPLOYEE_ACCOUNT_TYPE
};</code></pre><p>5) router 与 store 目录<br>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</p>
<p>router 尽量按照 views 中的结构保持一致</p>
<p>store 按照业务进行拆分不同的 js 文件</p>
<p>6) views 目录<br>命名要与后端、router、api 等保持一致</p>
<pre><code>components 中组件要使用 PascalCase 规则
|-- views                            视图目录
|   |-- role                             role模块名
|   |   |-- roleList.vue                    role列表页面
|   |   |-- roleAdd.vue                     role新建页面
|   |   |-- roleUpdate.vue                  role更新页面
|   |   |-- index.scss                      role模块样式
|   |   |-- components                      role模块通用组件文件夹
|   |   |   |-- RoleHeader.vue                        role头部组件
|   |   |   |-- RoleModal.vue                         role弹出框组件
|   |-- employee                         employee模块
|   |-- behaviorLog                      行为日志log模块
|   |-- codeGenerator                    代码生成器模块</code></pre><h4 id="2-2-4-注释说明"><a href="#2-2-4-注释说明" class="headerlink" title="2.2.4 注释说明"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p>
<p>公共组件使用说明<br>api 目录的接口 js 文件必须加注释<br>store 中的 state, mutation, action 等必须加注释<br>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释<br>vue 文件的 methods，每个 method 必须添加注释<br>vue 文件的 data, 非常见单词要加注释</p>
<h4 id="2-2-5-其他"><a href="#2-2-5-其他" class="headerlink" title="2.2.5 其他"></a>2.2.5 其他</h4><p>1) 尽量不要手动操作 DOM<br>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</p>
<p>2) 删除无用代码<br>因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis快速入门</title>
    <url>/posts/2991666428.html</url>
    <content><![CDATA[<h3 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1.Mybatis简介"></a>1.Mybatis简介</h3><h4 id="1-1原始jdbc操作（查询数据）"><a href="#1-1原始jdbc操作（查询数据）" class="headerlink" title="1.1原始jdbc操作（查询数据）"></a>1.1原始jdbc操作（查询数据）</h4><pre><code>//注册驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
//获得连接
Connection connection = DriverManager.
//获得statememt
PreparedStatement statememt = connection.prepareStatement(sql&quot;select id,username,password from user&quot;);
//执行查询
ResultSet resultSet = statememt.executeQuery();
//遍历结果集
while(resultSet.next()){
  //封装实体
  User user = new User();
  user.setId(resultSet.getInt(columnLabel:&quot;id&quot;));
  user.setUsername(resultSet.getString(columnLabel:&quot;username&quot;));
  user.setPassword(resultSet.getString(columnLabel:&quot;password&quot;));
  //user实体封装完毕
  System.out.println(user);
}
//释放资源
resultSet.close();
statememt.close();
connection.close();</code></pre><h4 id="1-2原始jdbc操作（插入数据）"><a href="#1-2原始jdbc操作（插入数据）" class="headerlink" title="1.2原始jdbc操作（插入数据）"></a>1.2原始jdbc操作（插入数据）</h4><pre><code>//模拟实体对象
User user = new User();
user.setId(123);
user.setUsername(&quot;admin&quot;);
user.setPassword(&quot;123456&quot;);

//注册驱动
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
//获得连接
Connection connection = DriverManager.
//获得statememt
PreparedStatement statememt = connection.prepareStatement(sql&quot;insert into user(id,username,password) values(?,?,?)&quot;);
//设置占位符参数

statememt.setId(1,user.getInt());
statememt.setUsername(2,user.getString());
statememt.setPassword(3,user.getString());
//释放资源
resultSet.close();
connection.close();</code></pre><h4 id="1-3-原始jdbc操作的分析"><a href="#1-3-原始jdbc操作的分析" class="headerlink" title="1.3 原始jdbc操作的分析"></a>1.3 原始jdbc操作的分析</h4><p>原始jdbc开发存在的问题如下：</p>
<p>①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能</p>
<p>②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。</p>
<p>③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</p>
<p>应对上述问题给出的解决方案：</p>
<p>①使用数据库连接池初始化连接资源</p>
<p>②将sql语句抽取到xml配置文件中</p>
<p>③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p>
<h4 id="1-4-什么是Mybatis"><a href="#1-4-什么是Mybatis" class="headerlink" title="1.4 什么是Mybatis"></a>1.4 什么是Mybatis</h4><p>mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</p>
<p>mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</p>
<p>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。</p>
<h3 id="2-Mybatis的快速入门"><a href="#2-Mybatis的快速入门" class="headerlink" title="2.Mybatis的快速入门"></a>2.Mybatis的快速入门</h3><h4 id="2-1-MyBatis开发步骤"><a href="#2-1-MyBatis开发步骤" class="headerlink" title="2.1 MyBatis开发步骤"></a>2.1 MyBatis开发步骤</h4><p>MyBatis官网地址：<a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/</a> </p>
<p><strong>MyBatis开发步骤：</strong></p>
<p>①添加MyBatis的坐标</p>
<p>②创建user数据表</p>
<p>③编写User实体类 </p>
<p>④编写映射文件UserMapper.xml</p>
<p>⑤编写核心文件SqlMapConfig.xml</p>
<p>⑥编写测试类</p>
<h4 id="2-2-环境搭建"><a href="#2-2-环境搭建" class="headerlink" title="2.2 环境搭建"></a>2.2 环境搭建</h4><p>1)导入MyBatis的坐标和其他相关坐标</p>
<pre><code>&lt;!--mybatis坐标--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--mysql驱动坐标--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;mysql&lt;/groupId&gt;   
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    
    &lt;version&gt;5.1.6&lt;/version&gt;    
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--单元测试坐标--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;junit&lt;/groupId&gt;    
    &lt;artifactId&gt;junit&lt;/artifactId&gt;    
    &lt;version&gt;4.12&lt;/version&gt;    
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--日志坐标--&gt;
&lt;dependency&gt;    
    &lt;groupId&gt;log4j&lt;/groupId&gt;    
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    
    &lt;version&gt;1.2.12&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>2)  创建user数据表</p>
<p><img src="img%5C%E5%9B%BE%E7%89%875.png" alt=""></p>
<p>3) 编写User实体</p>
<pre><code>public class User {    
  private int id;    
  private String username;    
  private String password;
    //省略get个set方法
}</code></pre><p>4)编写UserMapper映射文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper        
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;userMapper&quot;&gt;    
  &lt;select id=&quot;findAll&quot; resultType=&quot;com.demo.domain.User&quot;&gt;        
    select * from User    
  &lt;/select&gt;
&lt;/mapper&gt;</code></pre><p>5) 编写MyBatis核心文件</p>
<pre><code>&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;    
  &lt;environments default=&quot;development&quot;&gt;        
    &lt;environment id=&quot;development&quot;&gt;            
      &lt;transactionManager type=&quot;JDBC&quot;/&gt;            
      &lt;dataSource type=&quot;POOLED&quot;&gt;                
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;                
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            
      &lt;/dataSource&gt;        
    &lt;/environment&gt;    
  &lt;/environments&gt;    

  &lt;mappers&gt; 
    &lt;mapper resource=&quot;com/demo/mapper/UserMapper.xml&quot;/&gt; 
  &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre><h4 id="2-3-编写测试代码"><a href="#2-3-编写测试代码" class="headerlink" title="2.3 编写测试代码"></a>2.3 编写测试代码</h4><pre><code>//加载核心配置文件
InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
//获得sqlSession工厂对象
SqlSessionFactory sqlSessionFactory = new            
                          SqlSessionFactoryBuilder().build(resourceAsStream);
//获得sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession();
//执行sql语句
List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);
//打印结果
System.out.println(userList);
//释放资源
sqlSession.close();</code></pre><h4 id="2-4-知识小结"><a href="#2-4-知识小结" class="headerlink" title="2.4 知识小结"></a>2.4 知识小结</h4><p><strong>MyBatis开发步骤：</strong></p>
<p>①添加MyBatis的坐标</p>
<p>②创建user数据表</p>
<p>③编写User实体类 </p>
<p>④编写映射文件UserMapper.xml</p>
<p>⑤编写核心文件SqlMapConfig.xml</p>
<p>⑥编写测试类</p>
<h3 id="3-MyBatis的映射文件概述"><a href="#3-MyBatis的映射文件概述" class="headerlink" title="3. MyBatis的映射文件概述"></a>3. MyBatis的映射文件概述</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;userMapper&quot;&gt;

  &lt;!--删除操作--&gt;
  &lt;delete id=&quot;delete&quot; parameterType=&quot;int&quot;&gt;
      delete from user where id=#{abc}
  &lt;/delete&gt;

  &lt;!--修改操作--&gt;
  &lt;update id=&quot;update&quot; parameterType=&quot;com.demo.domain.User&quot;&gt;
      update user set username=#{username},password=#{password} where id=#{id}
  &lt;/update&gt;

  &lt;!--插入操作--&gt;
  &lt;insert id=&quot;save&quot; parameterType=&quot;com.demo.domain.User&quot;&gt;
      insert into user values(#{id},#{username},#{password})
  &lt;/insert&gt;

  &lt;!--查询操作--&gt;
  &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
      select * from user
  &lt;/select&gt;

  &lt;!--根据id进行查询--&gt;
  &lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot;&gt;
      select * from user where id=#{id}
  &lt;/select&gt;

&lt;/mapper&gt;</code></pre><h3 id="4-MyBatis的增删改查操作"><a href="#4-MyBatis的增删改查操作" class="headerlink" title="4. MyBatis的增删改查操作"></a>4. MyBatis的增删改查操作</h3><h4 id="4-1-MyBatis的插入数据操作"><a href="#4-1-MyBatis的插入数据操作" class="headerlink" title="4.1 MyBatis的插入数据操作"></a>4.1 MyBatis的插入数据操作</h4><p><strong>1)编写UserMapper映射文件</strong></p>
<pre><code>&lt;mapper namespace=&quot;userMapper&quot;&gt;    
  &lt;insert id=&quot;add&quot; parameterType=&quot;com.demo.domain.User&quot;&gt;        
    insert into user values(#{id},#{username},#{password})    
  &lt;/insert&gt;
&lt;/mapper&gt;</code></pre><p><strong>2)编写插入实体User的代码</strong></p>
<pre><code>InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
SqlSessionFactory sqlSessionFactory = new 
                        SqlSessionFactoryBuilder().build(resourceAsStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);
System.out.println(insert);
//提交事务
sqlSession.commit();
sqlSession.close();</code></pre><p><strong>3)插入操作注意问题</strong></p>
<p>• 插入语句使用insert标签</p>
<p>• 在映射文件中使用parameterType属性指定要插入的数据类型</p>
<p>•Sql语句中使用#{实体属性名}方式引用实体中的属性值</p>
<p>•插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象);</p>
<p>•插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() </p>
<h4 id="4-2-MyBatis的修改数据操作"><a href="#4-2-MyBatis的修改数据操作" class="headerlink" title="4.2 MyBatis的修改数据操作"></a>4.2 MyBatis的修改数据操作</h4><p><strong>1)编写UserMapper映射文件</strong></p>
<pre><code>&lt;mapper namespace=&quot;userMapper&quot;&gt;
    &lt;update id=&quot;update&quot; parameterType=&quot;com.demo.domain.User&quot;&gt;
        update user set username=#{username},password=#{password} where id=#{id}
    &lt;/update&gt;
&lt;/mapper&gt;</code></pre><p><strong>2)编写修改实体User的代码</strong></p>
<pre><code>InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
int update = sqlSession.update(&quot;userMapper.update&quot;, user);
System.out.println(update);
sqlSession.commit();
sqlSession.close();</code></pre><p><strong>3)修改操作注意问题</strong></p>
<p>• 修改语句使用update标签</p>
<p>• 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象);</p>
<h4 id="4-3-MyBatis的删除数据操作"><a href="#4-3-MyBatis的删除数据操作" class="headerlink" title="4.3 MyBatis的删除数据操作"></a>4.3 MyBatis的删除数据操作</h4><p><strong>1)编写UserMapper映射文件</strong></p>
<pre><code>&lt;mapper namespace=&quot;userMapper&quot;&gt;
    &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;
&lt;/mapper&gt;</code></pre><p><strong>2)编写删除数据的代码</strong></p>
<pre><code>InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);
System.out.println(delete);
sqlSession.commit();
sqlSession.close();</code></pre><p><strong>3)删除操作注意问题</strong></p>
<p>• 删除语句使用delete标签</p>
<p>•Sql语句中使用#{任意字符串}方式引用传递的单个参数</p>
<p>•删除操作使用的API是sqlSession.delete(“命名空间.id”,Object);</p>
<h4 id="4-4-知识小结"><a href="#4-4-知识小结" class="headerlink" title="4.4 知识小结"></a>4.4 知识小结</h4><pre><code>增删改查映射配置与API：
查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);
    &lt;select id=&quot;findAll&quot; resultType=&quot;com.demo.domain.User&quot;&gt;
        select * from User
    &lt;/select&gt;
添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user);
    &lt;insert id=&quot;add&quot; parameterType=&quot;com.demo.domain.User&quot;&gt;
        insert into user values(#{id},#{username},#{password})
    &lt;/insert&gt;
修改数据： sqlSession.update(&quot;userMapper.update&quot;, user);
    &lt;update id=&quot;update&quot; parameterType=&quot;com.demo.domain.User&quot;&gt;
        update user set username=#{username},password=#{password} where id=#{id}
    &lt;/update&gt;
删除数据：sqlSession.delete(&quot;userMapper.delete&quot;,3);
    &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;</code></pre><h3 id="5-MyBatis核心配置文件概述"><a href="#5-MyBatis核心配置文件概述" class="headerlink" title="5. MyBatis核心配置文件概述"></a>5. MyBatis核心配置文件概述</h3><h4 id="5-1-MyBatis核心配置文件层级关系"><a href="#5-1-MyBatis核心配置文件层级关系" class="headerlink" title="5.1 MyBatis核心配置文件层级关系"></a>5.1 MyBatis核心配置文件层级关系</h4><ul>
<li>configuration配置<ul>
<li>properties属性</li>
<li>setting设置</li>
<li>typeAliases类型别名</li>
<li>typeHandlers类型处理器</li>
<li>objectFactory对象工厂</li>
<li>plugins插件</li>
<li>environments环境<ul>
<li>environments环境变量<ul>
<li>transactionManager事务管理器</li>
<li>dataSource数据源</li>
</ul>
</li>
</ul>
</li>
<li>databaseProvide数据库厂商标识</li>
<li>mappers映射器</li>
</ul>
</li>
</ul>
<h4 id="5-2-MyBatis常用配置解析"><a href="#5-2-MyBatis常用配置解析" class="headerlink" title="5.2 MyBatis常用配置解析"></a>5.2 MyBatis常用配置解析</h4><p><strong>1)environments标签</strong></p>
<p>数据库环境的配置，支持多环境配置</p>
<pre><code>&lt;!--数据源环境--&gt;
// 指定默认的环境名称
&lt;environments default=&quot;developement&quot;&gt; 
    // 指定当前环境的名称
    &lt;environment id=&quot;developement&quot;&gt;
        //指定事务管理类型是JDBC
        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
        //指定当前数据源类型为连接池
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            // 数据源配置的基本参数
            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;</code></pre><p>其中，事务管理器（transactionManager）类型有两种：</p>
<p>•JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。</p>
<p>•MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。</p>
<p>其中，数据源（dataSource）类型有三种：</p>
<p>•UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。</p>
<p>•POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。</p>
<p>•JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p>
<p><strong>2)mapper标签</strong></p>
<p>该标签的作用是加载映射的，加载方式有如下几种：</p>
<p>•使用相对于类路径的资源引用，例如：</p>
<mapper resource="org/mybatis/builder/AuthorMapper.xml"/>

<p>•使用完全限定资源定位符（URL），例如：</p>
<mapper url="file:///var/mappers/AuthorMapper.xml"/>

<p>•使用映射器接口实现类的完全限定类名，例如：</p>
<mapper class="org.mybatis.builder.AuthorMapper"/>

<p>•将包内的映射器接口实现全部注册为映射器，例如：</p>
<package name="org.mybatis.builder"/>

<p><strong>3)Properties标签</strong></p>
<p>实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件</p>
<pre><code>&lt;!--通过properties标签加载外部properties文件--&gt;
&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</code></pre><p><strong>4)typeAliases标签</strong></p>
<p>类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下</p>
<pre><code>&lt;!--查询操作--&gt;
&lt;select id=&quot;findAll&quot; resultType=&quot;com.demo.domain.User&quot;&gt;
    select * from user
&lt;/select&gt;</code></pre><p>配置typeAliases，为com.demo.domain.User定义别名为user</p>
<pre><code>&lt;!--自定义别名--&gt;
&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.demo.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;
&lt;/typeAliases&gt;
// 使用别名
&lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;</code></pre><p>上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名</p>
<h4 id="5-3-知识小结"><a href="#5-3-知识小结" class="headerlink" title="5.3 知识小结"></a>5.3 知识小结</h4><p><strong>核心配置文件常用配置：</strong></p>
<p>properties标签：该标签可以加载外部的properties文件</p>
<pre><code>&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</code></pre><p>typeAliases标签：设置类型别名</p>
<pre><code>&lt;typeAlias type=&quot;com.demo.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;</code></pre><p>mappers标签：加载映射配置</p>
<pre><code>&lt;mapper resource=&quot;com/demo/mapper/UserMapping.xml&quot;&gt;&lt;/mapper&gt;</code></pre><p>environments标签：数据源环境配置标签</p>
<pre><code>&lt;!--数据源环境--&gt;
&lt;environments default=&quot;developement&quot;&gt;
    &lt;environment id=&quot;developement&quot;&gt;
        &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
            &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
        &lt;/dataSource&gt;
    &lt;/environment&gt;
&lt;/environments&gt;</code></pre><h3 id="6-MyBatis相应API"><a href="#6-MyBatis相应API" class="headerlink" title="6.MyBatis相应API"></a>6.MyBatis相应API</h3><h4 id="6-1-SqlSession工厂构建器SqlSessionFactoryBuilder"><a href="#6-1-SqlSession工厂构建器SqlSessionFactoryBuilder" class="headerlink" title="6.1 SqlSession工厂构建器SqlSessionFactoryBuilder"></a>6.1 SqlSession工厂构建器SqlSessionFactoryBuilder</h4><p>常用API：SqlSessionFactory  build(InputStream inputStream)</p>
<p>通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p>
<pre><code>String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; 
InputStream inputStream = Resources.getResourceAsStream(resource); 
SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); 
SqlSessionFactory factory = builder.build(inputStream);</code></pre><p>其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。</p>
<h4 id="6-2-SqlSession工厂对象SqlSessionFactory"><a href="#6-2-SqlSession工厂对象SqlSessionFactory" class="headerlink" title="6.2 SqlSession工厂对象SqlSessionFactory"></a>6.2 SqlSession工厂对象SqlSessionFactory</h4><p>SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个：</p>
<ul>
<li>openSession()<ul>
<li>会默认开启一个事务，但事务不会自动提交，也就意味着需要手动提交该事务，更新操作数据才会持久化到数据库中</li>
</ul>
</li>
<li>openSession(bloolean autoCommit)<ul>
<li>参数为是否自动提交，如果设置为true，那么不需要手动提交事务</li>
</ul>
</li>
</ul>
<h4 id="6-3-SqlSession会话对象"><a href="#6-3-SqlSession会话对象" class="headerlink" title="6.3 SqlSession会话对象"></a>6.3 SqlSession会话对象</h4><p>SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。</p>
<p>执行语句的方法主要有：</p>
<pre><code>&lt;T&gt; T selectOne(String statement, Object parameter) 
&lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) 
int insert(String statement, Object parameter) 
int update(String statement, Object parameter) 
int delete(String statement, Object parameter)</code></pre><p>操作事务的方法主要有：</p>
<pre><code>void commit()  
void rollback() </code></pre>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础学习</title>
    <url>/posts/2112151695.html</url>
    <content><![CDATA[<h2 id="1-spring概述"><a href="#1-spring概述" class="headerlink" title="1. spring概述"></a>1. spring概述</h2><h3 id="1-1-Spring是什么（理解）"><a href="#1-1-Spring是什么（理解）" class="headerlink" title="1.1 Spring是什么（理解）"></a>1.1 Spring是什么（理解）</h3><p>Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。</p>
<p>提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架</p>
<h3 id="1-2-Spring发展历程-（了解）"><a href="#1-2-Spring发展历程-（了解）" class="headerlink" title="1.2 Spring发展历程 （了解）"></a>1.2 Spring发展历程 （了解）</h3><p>Rod Johnson （ Spring 之父）</p>
<p>2017  年<br>9 月份发布了 Spring 的最新版本 Spring5.0<br>通用版（GA）</p>
<h3 id="1-3-Spring的优势（理解）"><a href="#1-3-Spring的优势（理解）" class="headerlink" title="1.3 Spring的优势（理解）"></a>1.3 Spring的优势（理解）</h3><p>方便解耦，简化开发</p>
<p>AOP 编程的支持</p>
<p>声明式事务的支持</p>
<p>方便程序的测试</p>
<h3 id="1-4-Spring的体系结构（了解）"><a href="#1-4-Spring的体系结构（了解）" class="headerlink" title="1.4 Spring的体系结构（了解）"></a>1.4 Spring的体系结构（了解）</h3><h2 id="2-spring快速入门"><a href="#2-spring快速入门" class="headerlink" title="2. spring快速入门"></a>2. spring快速入门</h2><h3 id="2-1-Spring程序开发步骤"><a href="#2-1-Spring程序开发步骤" class="headerlink" title="2.1 Spring程序开发步骤"></a>2.1 Spring程序开发步骤</h3><p>①导入 Spring 开发的基本包坐标</p>
<p>②编写 Dao 接口和实现类</p>
<p>③创建 Spring 核心配置文件</p>
<p>④在 Spring 配置文件中配置 UserDaoImpl</p>
<p>⑤使用 Spring 的 API 获得 Bean 实例</p>
<h3 id="2-2-导入Spring开发的基本包坐标"><a href="#2-2-导入Spring开发的基本包坐标" class="headerlink" title="2.2 导入Spring开发的基本包坐标"></a>2.2 导入Spring开发的基本包坐标</h3><pre><code>//xml
&lt;properties&gt;
  &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;
&lt;/properties&gt;
&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;
&lt;dependencies&gt; 
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework&lt;/groupId&gt; 
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt; 
        &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h3 id="2-3-编写Dao接口和实现类"><a href="#2-3-编写Dao接口和实现类" class="headerlink" title="2.3 编写Dao接口和实现类"></a>2.3 编写Dao接口和实现类</h3><pre><code>//java
public interface UserDao {  
    public void save();
}

public class UserDaoImpl implements UserDao {  
        @Override  
        public void save() {
          System.out.println(&quot;UserDao save method running....&quot;);
  }
}</code></pre><h3 id="2-4-创建Spring核心配置文件"><a href="#2-4-创建Spring核心配置文件" class="headerlink" title="2.4 创建Spring核心配置文件"></a>2.4 创建Spring核心配置文件</h3><p>在类路径下（resources）创建applicationContext.xml配置文件</p>
<pre><code>//xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;/beans&gt;</code></pre><h3 id="2-5-在Spring配置文件中配置UserDaoImpl"><a href="#2-5-在Spring配置文件中配置UserDaoImpl" class="headerlink" title="2.5 在Spring配置文件中配置UserDaoImpl"></a>2.5 在Spring配置文件中配置UserDaoImpl</h3><pre><code>//xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;</code></pre><h3 id="2-6-使用Spring的API获得Bean实例"><a href="#2-6-使用Spring的API获得Bean实例" class="headerlink" title="2.6 使用Spring的API获得Bean实例"></a>2.6 使用Spring的API获得Bean实例</h3><pre><code>//java
@Test
public void test1(){
    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;);
        userDao.save();
}</code></pre><h2 id="3-Spring配置文件"><a href="#3-Spring配置文件" class="headerlink" title="3. Spring配置文件"></a>3. Spring配置文件</h2><h3 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h3><p>用于配置对象交由Spring 来创建。</p>
<p>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p>
<p>基本属性：</p>
<p>id：Bean实例在Spring容器中的唯一标识</p>
<p>class：Bean的全限定名称</p>
<h3 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h3><p>scope:指对象的作用范围，取值如下： </p>
<table>
<thead>
<tr>
<th>取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>默认值，单例的</td>
</tr>
<tr>
<td>prototype</td>
<td>多例的</td>
</tr>
<tr>
<td>request</td>
<td>WEB   项目中，Spring   创建一个   Bean   的对象，将对象存入到   request   域中</td>
</tr>
<tr>
<td>session</td>
<td>WEB   项目中，Spring   创建一个   Bean   的对象，将对象存入到   session   域中</td>
</tr>
<tr>
<td>global   session</td>
<td>WEB   项目中，应用在   Portlet   环境，如果没有   Portlet   环境那么globalSession   相当于   session</td>
</tr>
</tbody></table>
<p>1）当scope的取值为singleton时</p>
<p>​      Bean的实例化个数：1个</p>
<p>​      Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</p>
<p>​      Bean的生命周期：</p>
<p>对象创建：当应用加载，创建容器时，对象就被创建了</p>
<p>对象运行：只要容器在，对象一直活着</p>
<p>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</p>
<p>2）当scope的取值为prototype时</p>
<p>​      Bean的实例化个数：多个</p>
<p>​      Bean的实例化时机：当调用getBean()方法时实例化Bean</p>
<p>对象创建：当使用对象时，创建新的对象实例</p>
<p>对象运行：只要对象在使用中，就一直活着</p>
<p>对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了</p>
<h3 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h3><p>init-method：指定类中的初始化方法名称</p>
<p>destroy-method：指定类中销毁方法名称</p>
<h3 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h3><p>1） 使用无参构造方法实例化</p>
<p>​      它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败</p>
<pre><code>//xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;/&gt;</code></pre><p>2） 工厂静态方法实例化</p>
<p>​      工厂的静态方法返回Bean实例</p>
<pre><code>//java
public class StaticFactoryBean {
    public static UserDao createUserDao(){    
    return new UserDaoImpl();
    }
}

//xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.factory.StaticFactoryBean&quot; 
      factory-method=&quot;createUserDao&quot; /&gt;</code></pre><p>3） 工厂实例方法实例化</p>
<p>​      工厂的非静态方法返回Bean实例</p>
<pre><code>//java
public class DynamicFactoryBean {  
  public UserDao createUserDao(){        
    return new UserDaoImpl(); 
  }
}


//xml
&lt;bean id=&quot;factoryBean&quot; class=&quot;com.demo.factory.DynamicFactoryBean&quot;/&gt;
&lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt;</code></pre><h3 id="3-5-Bean的依赖注入入门"><a href="#3-5-Bean的依赖注入入门" class="headerlink" title="3.5 Bean的依赖注入入门"></a>3.5 Bean的依赖注入入门</h3><p>①创建 UserService，UserService 内部在调用 UserDao的save() 方法</p>
<pre><code>//java
public class UserServiceImpl implements UserService {
  @Override
  public void save() {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
          UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;);    
          userDao.save();
  }
}</code></pre><p>②将 UserServiceImpl 的创建权交给 Spring</p>
<pre><code>//xml
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.impl.UserServiceImpl&quot;/&gt;</code></pre><p>③从 Spring 容器中获得 UserService 进行操作</p>
<pre><code>//java
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);
userService.save();</code></pre><h3 id="3-6-Bean的依赖注入概念"><a href="#3-6-Bean的依赖注入概念" class="headerlink" title="3.6 Bean的依赖注入概念"></a>3.6 Bean的依赖注入概念</h3><p>依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。</p>
<p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p>
<p>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p>
<p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。</p>
<p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</p>
<h3 id="3-7-Bean的依赖注入方式"><a href="#3-7-Bean的依赖注入方式" class="headerlink" title="3.7 Bean的依赖注入方式"></a>3.7 Bean的依赖注入方式</h3><p>①构造方法</p>
<pre><code>//创建有参构造
//java
public class UserServiceImpl implements UserService {
@Override
public void save() {
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;);    
          userDao.save();
    }
}


//配置Spring容器调用有参构造时进行注入
//xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;/&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.impl.UserServiceImpl&quot;&gt; 
  &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><p>②set方法</p>
<pre><code>//在UserServiceImpl中添加setUserDao方法
//java
public class UserServiceImpl implements UserService {
    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;  
        } 
    @Override    
    public void save() {      
      userDao.save();
  }
}</code></pre><p>​      配置Spring容器调用set方法进行注入</p>
<pre><code>//xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;/&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.impl.UserServiceImpl&quot;&gt;
  &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;
&lt;/bean&gt;</code></pre><p>set方法:P命名空间注入</p>
<p>​      P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：</p>
<p>​      首先，需要引入P命名空间：</p>
<pre><code>//xml
xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></pre><p>其次，需要修改注入方式</p>
<pre><code>//xml
&lt;bean id=&quot;userService&quot; class=&quot;com.demo.service.impl.UserServiceImpl&quot; p:userDao-
ref=&quot;userDao&quot;/&gt;</code></pre><h3 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h3><p>上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p>
<p>注入数据的三种数据类型 </p>
<p>普通数据类型</p>
<p>引用数据类型</p>
<p>集合数据类型</p>
<p>其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p>
<p><strong>Bean的依赖注入的数据类型</strong></p>
<p>（1）普通数据类型的注入</p>
<pre><code>//java
public class UserDaoImpl implements UserDao {
private String company;
    private int age;
    public void setCompany(String company) {
        this.company = company;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public void save() {
        System.out.println(company+&quot;===&quot;+age);
        System.out.println(&quot;UserDao save method running....&quot;);   
    }
}


//xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;company&quot; value=&quot;德玛西亚&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre><p>（2）集合数据类型（List<String>）的注入</p>
<pre><code>//java
public class UserDaoImpl implements UserDao {
  private List&lt;String&gt; strList;
  public void setStrList(List&lt;String&gt; strList) {
    this.strList = strList;
  }
  public void save() {
        System.out.println(strList);
        System.out.println(&quot;UserDao save method running....&quot;);
  }
}


//xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;strList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;aaa&lt;/value&gt;
            &lt;value&gt;bbb&lt;/value&gt;
            &lt;value&gt;ccc&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><p>（3）集合数据类型（List<User>）的注入</p>
<pre><code>//java
public class UserDaoImpl implements UserDao {
  private List&lt;User&gt; userList;
  public void setUserList(List&lt;User&gt; userList) {
  this.userList = userList;  
}
public void save() {
  System.out.println(userList);
  System.out.println(&quot;UserDao save method running....&quot;);
  }
}


//xml
&lt;bean id=&quot;u1&quot; class=&quot;com.demo.domain.User&quot;/&gt;
&lt;bean id=&quot;u2&quot; class=&quot;com.demo.domain.User&quot;/&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;userList&quot;&gt;
        &lt;list&gt;
            &lt;bean class=&quot;com.demo.domain.User&quot;/&gt;
            &lt;bean class=&quot;com.demo.domain.User&quot;/&gt;
            &lt;ref bean=&quot;u1&quot;/&gt;
            &lt;ref bean=&quot;u2&quot;/&gt;       
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><p>（4）集合数据类型（ Map&lt;String,User&gt; ）的注入</p>
<pre><code>//java
public class UserDaoImpl implements UserDao {
    private Map&lt;String,User&gt; userMap;
    public void setUserMap(Map&lt;String, User&gt; userMap) {
    this.userMap = userMap;
    }    
public void save() {      
  System.out.println(userMap);
  System.out.println(&quot;UserDao save method running....&quot;);
  }
}


//xml
&lt;bean id=&quot;u1&quot; class=&quot;com.demo.domain.User&quot;/&gt;
&lt;bean id=&quot;u2&quot; class=&quot;com.demo.domain.User&quot;/&gt;
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;userMap&quot;&gt;
        &lt;map&gt;            
            &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt;
            &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><p>（5）集合数据类型（Properties）的注入</p>
<pre><code>// java
public class UserDaoImpl implements UserDao {
    private Properties properties;
    public void setProperties(Properties properties) {
        this.properties = properties;
    }
  public void save() {
    System.out.println(properties);
    System.out.println(&quot;UserDao save method running....&quot;);
  }
}

// xml
&lt;bean id=&quot;userDao&quot; class=&quot;com.demo.dao.impl.UserDaoImpl&quot;&gt;
    &lt;property name=&quot;properties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt;
            &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; 
            &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><h3 id="3-9-引入其他配置文件（分模块开发）"><a href="#3-9-引入其他配置文件（分模块开发）" class="headerlink" title="3.9 引入其他配置文件（分模块开发）"></a>3.9 引入其他配置文件（分模块开发）</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载</p>
<pre><code>import resource=&quot;applicationContext-xxx.xml&quot;/&gt;</code></pre><h2 id="4-spring相关API"><a href="#4-spring相关API" class="headerlink" title="4. spring相关API"></a>4. spring相关API</h2><h3 id="4-1-ApplicationContext的继承体系"><a href="#4-1-ApplicationContext的继承体系" class="headerlink" title="4.1 ApplicationContext的继承体系"></a>4.1 ApplicationContext的继承体系</h3><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象</p>
<h3 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h3><p>1）ClassPathXmlApplicationContext </p>
<p>​      它是从类的根路径下加载配置文件 推荐使用这种</p>
<p>2）FileSystemXmlApplicationContext </p>
<p>​      它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p>
<p>3）AnnotationConfigApplicationContext</p>
<p>​      当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p>
<h3 id="4-3-getBean-方法使用"><a href="#4-3-getBean-方法使用" class="headerlink" title="4.3 getBean()方法使用"></a>4.3 getBean()方法使用</h3><pre><code>public Object getBean(String name) throws BeansException {  
  assertBeanFactoryActive();   
  return getBeanFactory().getBean(name);
}
public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException {                       
  assertBeanFactoryActive();
  return getBeanFactory().getBean(requiredType);
}</code></pre><p>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。</p>
<p>当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错</p>
<p><strong>getBean()方法使用</strong></p>
<pre><code>ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;);
UserService userService2 = applicationContext.getBean(UserService.class);</code></pre>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用brew安装与配置MySQL</title>
    <url>/posts/458106393.html</url>
    <content><![CDATA[<h1 id="使用Homebrew安装MySQL"><a href="#使用Homebrew安装MySQL" class="headerlink" title="使用Homebrew安装MySQL"></a>使用Homebrew安装MySQL</h1><ol>
<li>如果没有安装Homebrew，首先安装Homebrew<ul>
<li>打开终端输入以下命令：</li>
</ul>
</li>
</ol>
<pre><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></pre><ol start="2">
<li>使用Homebrew安装命令</li>
</ol>
<pre><code>brew install mysql</code></pre><ol start="3">
<li>启动mysql服务</li>
</ol>
<pre><code>mysql.server start</code></pre><ol start="4">
<li>初始化mysql配置</li>
</ol>
<pre><code>HaojiedeiMac:~ haojie$ mysql_secure_installation

Securing the MySQL server deployment.

Connecting to MySQL using a blank password.

VALIDATE PASSWORD COMPONENT can be used to test passwords
and improve security. It checks the strength of password
and allows the users to set only those passwords which are
secure enough. Would you like to setup VALIDATE PASSWORD component?

Press y|Y for Yes, any other key for No: n  // 这个选yes的话密码长度就必须要设置为8位以上，但我只设置4位
Please set the password for root here.

New password:               // 设置密码

Re-enter new password:      // 再一次确认密码
By default, a MySQL installation has an anonymous user,
allowing anyone to log into MySQL without having to have
a user account created for them. This is intended only for
testing, and to make the installation go a bit smoother.
You should remove them before moving into a production
environment.

Remove anonymous users? (Press y|Y for Yes, any other key for No) : y       // 移除不用密码的那个账户
Success.


Normally, root should only be allowed to connect from
&apos;localhost&apos;. This ensures that someone cannot guess at
the root password from the network.

Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n     //不接受root远程登录账号

... skipping.
By default, MySQL comes with a database named &apos;test&apos; that
anyone can access. This is also intended only for testing,
and should be removed before moving into a production
environment.


Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y    //删除test数据库
- Dropping test database...
Success.

- Removing privileges on test database...
Success.

Reloading the privilege tables will ensure that all changes
made so far will take effect immediately.

Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y      // 是否重新加载授权信息
Success.

All done! </code></pre>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装Redis</title>
    <url>/posts/2493102751.html</url>
    <content><![CDATA[<h1 id="使用Homebrew安装Redis"><a href="#使用Homebrew安装Redis" class="headerlink" title="使用Homebrew安装Redis"></a>使用Homebrew安装Redis</h1><ol>
<li>如果没有安装Homebrew，首先安装Homebrew<ul>
<li>打开终端输入以下命令：</li>
</ul>
</li>
</ol>
<pre><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></pre><ol start="2">
<li>使用Homebrew安装命令</li>
</ol>
<pre><code>brew install redis</code></pre><p>  执行上述命令后出现以下，则成功安装：</p>
<pre><code>==&gt; Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/redis-6.0.1
######################################################################## 100.0%
==&gt; Pouring redis-6.0.1.mojave.bottle.tar.gz
==&gt; Caveats
To have launchd start redis now and restart at login:
brew services start redis
Or, if you don&apos;t want/need a background service you can just run:
redis-server /usr/local/etc/redis.conf
==&gt; Summary
🍺  /usr/local/Cellar/redis/6.0.1: 13 files, 3.7MB</code></pre><ol start="3">
<li><p>查看安装及配置文件位置</p>
<ul>
<li><p>Homebrew安装的软件会默认在/usr/local/Cellar/路径下</p>
</li>
<li><p>redis的配置文件redis.conf存放在/usr/local/etc路径下</p>
</li>
</ul>
</li>
<li><p>启动redis服务</p>
</li>
</ol>
<pre><code>//方式一：使用brew帮助我们启动软件
brew services start redis
//方式二
redis-server /usr/local/etc/redis.conf


//执行以下命令
redis-server</code></pre><ol start="5">
<li><p>查看redis服务进程</p>
<ul>
<li>我们可以通过下面命令查看redis是否正在运行</li>
</ul>
</li>
</ol>
<pre><code>ps axu | grep redis</code></pre><ol start="6">
<li><p>redis-cli连接redis服务</p>
<ul>
<li>redis默认端口号6379，默认auth为空，输入以下命令即可连接</li>
</ul>
</li>
</ol>
<pre><code>redis-cli -h 127.0.0.1 -p 6379</code></pre><ol start="7">
<li>启动 redis 客户端，打开终端并输入命令 redis-cli。该命令会连接本地的 redis 服务。</li>
</ol>
<pre><code>$redis-cli
redis 127.0.0.1:6379&gt;
redis 127.0.0.1:6379&gt; PING
PONG</code></pre><p>在以上实例中我们连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。</p>
<ol start="8">
<li><p>关闭redis服务</p>
<ul>
<li>正确停止Redis的方式应该是向Redis发送SHUTDOWN命令</li>
</ul>
</li>
</ol>
<pre><code>redis-cli shutdown</code></pre><ul>
<li>强行终止redis</li>
</ul>
<pre><code>sudo pkill redis-server</code></pre><ol start="9">
<li><p>redis.conf 配置文件详解</p>
<ul>
<li>redis默认是前台启动，如果我们想以守护进程的方式运行（后台运行），可以在redis.conf中将daemonize no,修改成yes即可。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>react基础</title>
    <url>/posts/1715802062.html</url>
    <content><![CDATA[<h3 id="react核心"><a href="#react核心" class="headerlink" title="react核心"></a>react核心</h3><ol>
<li>react.js<ul>
<li>核心文件</li>
<li>npm i react -S</li>
</ul>
</li>
<li>react-dom.js<ul>
<li>渲染页面中的DOM 当前文件依赖于react核心文件</li>
<li>npm i react-dom -S</li>
</ul>
</li>
<li>babel.js  <ul>
<li>ES6转换成ES5 JSX语法转换成js 现今浏览器进行代码的兼容</li>
<li>npm i babel-standalone -S</li>
</ul>
</li>
<li>jsx = javascript xml <ul>
<li>javascript的扩展语法，执行的效率更快</li>
<li>类型安全的，编译过程中就能及时发现错误</li>
<li>在使用jsx的时候编写模板会更加简单和快速</li>
</ul>
</li>
</ol>
<h3 id="react开发环境的搭建"><a href="#react开发环境的搭建" class="headerlink" title="react开发环境的搭建"></a>react开发环境的搭建</h3><ol>
<li>新建文件夹react</li>
<li>react文件夹中打开cmd初始化文件npm init</li>
<li>npm安装react必备文件</li>
<li>根目录新建index.html</li>
<li>在html文件中script引入src=”./node_modules/react/umd/react.development.js”</li>
<li>在html文件中script引入src=”./node_modules/react-dom/umd/react-dom.development.js”</li>
<li>在html文件中script引入src=”./node_modules/babel-standalone/babel.min.js”</li>
<li>在html文件body中创建根节点</li>
</ol>
<pre><code>// 1.使用表达式/变量 {表达式/变量}
let hello = &apos;hello world！&apos;
let n = &apos;haojie&apos;
function name(params) {
  return `姓名是${params}`
}
let myDom = &lt;div&gt;
              &lt;h1&gt;{hello}&lt;/h1&gt;
              &lt;div&gt;{name(n)}&lt;/div&gt;
            &lt;/div&gt;
ReactDOM.render(myDom, document.getElementById(&apos;react&apos;))</code></pre><h3 id="jsx的基本使用"><a href="#jsx的基本使用" class="headerlink" title="jsx的基本使用"></a>jsx的基本使用</h3><ol>
<li></li>
</ol>
]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>实用的Vue自定义指令</title>
    <url>/posts/955252516.html</url>
    <content><![CDATA[<p>在 Vue，除了核心功能默认内置的指令 ( v-model 和 v-show )，Vue 也允许注册自定义指令。它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作。</p>
<p>Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。</p>
<p>批量注册指令，新建 directives/index.js 文件</p>
<pre><code>import copy from &apos;./copy&apos;
import longpress from &apos;./longpress&apos;
// 自定义指令
const directives = {
  copy,
  longpress,
}

export default {
  install(Vue) {
    Object.keys(directives).forEach((key) =&gt; {
      Vue.directive(key, directives[key])
    })
  },
}</code></pre><p>在 main.js 引入并调用import Vue from ‘vue’</p>
<pre><code>import Directives from &apos;./JS/directives&apos;
Vue.use(Directives)</code></pre><p>指令定义函数提供了几个钩子函数（可选）：</p>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<p><strong>下面分享几个实用的 Vue 自定义指令</strong></p>
<ul>
<li>复制粘贴指令 v-copy</li>
<li>长按指令 v-longpress</li>
<li>输入框防抖指令 v-debounce</li>
<li>禁止表情及特殊字符 v-emoji</li>
<li>图片懒加载 v-LazyLoad</li>
<li>权限校验指令 v-premission</li>
<li>实现页面水印 v-waterMarker</li>
<li>拖拽指令 v-draggable</li>
</ul>
<h3 id="v-copy"><a href="#v-copy" class="headerlink" title="v-copy"></a>v-copy</h3><p>需求：实现一键复制文本内容，用于鼠标右键粘贴。<br>思路：</p>
<ol>
<li>动态创建 textarea 标签，并设置 readOnly 属性及移出可视区域</li>
<li>将要复制的值赋给 textarea 标签的 value 属性，并插入到 body</li>
<li>选中值 textarea 并复制</li>
<li>将 body 中插入的 textarea 移除</li>
<li>在第一次调用时绑定事件，在解绑时移除事件</li>
</ol>
<pre><code>const copy = {
  bind(el, { value }) {
    el.$value = value
    el.handler = () =&gt; {
      if (!el.$value) {
        // 值为空的时候，给出提示。可根据项目UI仔细设计
        console.log(&apos;无复制内容&apos;)
        return
      }
      // 动态创建 textarea 标签
      const textarea = document.createElement(&apos;textarea&apos;)
      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域
      textarea.readOnly = &apos;readonly&apos;
      textarea.style.position = &apos;absolute&apos;
      textarea.style.left = &apos;-9999px&apos;
      // 将要 copy 的值赋给 textarea 标签的 value 属性
      textarea.value = el.$value
      // 将 textarea 插入到 body 中
      document.body.appendChild(textarea)
      // 选中值并复制
      textarea.select()
      const result = document.execCommand(&apos;Copy&apos;)
      if (result) {
        console.log(&apos;复制成功&apos;) // 可根据项目UI仔细设计
      }
      document.body.removeChild(textarea)
    }
    // 绑定点击事件，就是所谓的一键 copy 啦
    el.addEventListener(&apos;click&apos;, el.handler)
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener(&apos;click&apos;, el.handler)
  },
}

export default copy</code></pre><p>使用：给 Dom 加上 v-copy 及复制的文本即可</p>
<pre><code>&lt;template&gt;
  &lt;button v-copy=&quot;copyText&quot;&gt;复制&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt; export default {
    data() {
      return {
        copyText: &apos;a copy directives&apos;,
      }
    },
  }
&lt;/script&gt;</code></pre><h3 id="v-longpress"><a href="#v-longpress" class="headerlink" title="v-longpress"></a>v-longpress</h3><p>需求：实现长按，用户需要按下并按住按钮几秒钟，触发相应的事件</p>
<p>思路：</p>
<ol>
<li>创建一个计时器， 2 秒后执行函数</li>
<li>当用户按下按钮时触发 mousedown 事件，启动计时器；用户松开按钮时调用 mouseout 事件。</li>
<li>如果 mouseup 事件 2 秒内被触发，就清除计时器，当作一个普通的点击事件</li>
<li>如果计时器没有在 2 秒内清除，则判定为一次长按，可以执行关联的函数。</li>
<li>在移动端要考虑 touchstart，touchend 事件</li>
</ol>
<pre><code>const longpress = {
  bind: function (el, binding, vNode) {
    if (typeof binding.value !== &apos;function&apos;) {
      throw &apos;callback must be a function&apos;
    }
    // 定义变量
    let pressTimer = null
    // 创建计时器（ 2秒后执行函数 ）
    let start = (e) =&gt; {
      if (e.type === &apos;click&apos; &amp;&amp; e.button !== 0) {
        return
      }
      if (pressTimer === null) {
        pressTimer = setTimeout(() =&gt; {
          handler()
        }, 2000)
      }
    }
    // 取消计时器
    let cancel = (e) =&gt; {
      if (pressTimer !== null) {
        clearTimeout(pressTimer)
        pressTimer = null
      }
    }
    // 运行函数
    const handler = (e) =&gt; {
      binding.value(e)
    }
    // 添加事件监听器
    el.addEventListener(&apos;mousedown&apos;, start)
    el.addEventListener(&apos;touchstart&apos;, start)
    // 取消计时器
    el.addEventListener(&apos;click&apos;, cancel)
    el.addEventListener(&apos;mouseout&apos;, cancel)
    el.addEventListener(&apos;touchend&apos;, cancel)
    el.addEventListener(&apos;touchcancel&apos;, cancel)
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener(&apos;click&apos;, el.handler)
  },
}

export default longpress</code></pre><p>使用：给 Dom 加上 v-longpress 及回调函数即可</p>
<pre><code>&lt;template&gt;
  &lt;button v-longpress=&quot;longpress&quot;&gt;长按&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt; 
export default {
  methods: {
    longpress () {
      alert(&apos;长按指令生效&apos;)
    }
  }
} 
&lt;/script&gt;</code></pre><h3 id="v-debounce"><a href="#v-debounce" class="headerlink" title="v-debounce"></a>v-debounce</h3><p>背景：在开发中，有些提交保存按钮有时候会在短时间内被点击多次，这样就会多次重复请求后端接口，造成数据的混乱，比如新增表单的提交按钮，多次点击就会新增多条重复的数据。<br>需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。<br>思路：</p>
<ol>
<li>定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。</li>
<li>将时间绑定在 click 方法上。</li>
</ol>
<pre><code>const debounce = {
  inserted: function (el, binding) {
    let timer
    el.addEventListener(&apos;keyup&apos;, () =&gt; {
      if (timer) {
        clearTimeout(timer)
      }
      timer = setTimeout(() =&gt; {
        binding.value()
      }, 1000)
    })
  },
}

export default debounce</code></pre><p>使用：给 Dom 加上 v-debounce 及回调函数即可</p>
<pre><code>&lt;template&gt;
  &lt;button v-debounce=&quot;debounceClick&quot;&gt;防抖&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt; 
export default {
  methods: {
    debounceClick () {
      console.log(&apos;只触发一次&apos;)
    }
  }
} 
&lt;/script&gt;</code></pre><h3 id="v-emoji"><a href="#v-emoji" class="headerlink" title="v-emoji"></a>v-emoji</h3><p>背景：开发中遇到的表单输入，往往会有对输入内容的限制，比如不能输入表情和特殊字符，只能输入数字或字母等。</p>
<p>我们常规方法是在每一个表单的 on-change 事件上做处理。</p>
<pre><code>&lt;template&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;note&quot; @change=&quot;vaidateEmoji&quot; /&gt;
&lt;/template&gt;

&lt;script&gt; export default {
    methods: {
      vaidateEmoji() {
        var reg = /[^u4E00-u9FA5|d|a-zA-Z|rns,.?!，。？！…—&amp;$=()-+/*{}[]]|s/g
        this.note = this.note.replace(reg, &apos;&apos;)
      },
    },
  } 
&lt;/script&gt;</code></pre><p>这样代码量比较大而且不好维护，所以我们需要自定义一个指令来解决这问题。</p>
<p>需求：根据正则表达式，设计自定义处理表单输入规则的指令，下面以禁止输入表情和特殊字符为例。</p>
<pre><code>let findEle = (parent, type) =&gt; {
  return parent.tagName.toLowerCase() === type ? parent : parent.querySelector(type)
}

const trigger = (el, type) =&gt; {
  const e = document.createEvent(&apos;HTMLEvents&apos;)
  e.initEvent(type, true, true)
  el.dispatchEvent(e)
}

const emoji = {
  bind: function (el, binding, vnode) {
    // 正则规则可根据需求自定义
    var regRule = /[^u4E00-u9FA5|d|a-zA-Z|rns,.?!，。？！…—&amp;$=()-+/*{}[]]|s/g
    let $inp = findEle(el, &apos;input&apos;)
    el.$inp = $inp
    $inp.handle = function () {
      let val = $inp.value
      $inp.value = val.replace(regRule, &apos;&apos;)

      trigger($inp, &apos;input&apos;)
    }
    $inp.addEventListener(&apos;keyup&apos;, $inp.handle)
  },
  unbind: function (el) {
    el.$inp.removeEventListener(&apos;keyup&apos;, el.$inp.handle)
  },
}

export default emoji</code></pre><p>使用：将需要校验的输入框加上 v-emoji 即可</p>
<pre><code>&lt;template&gt;
  &lt;input type=&quot;text&quot; v-model=&quot;note&quot; v-emoji /&gt;
&lt;/template&gt;</code></pre><h3 id="v-LazyLoad"><a href="#v-LazyLoad" class="headerlink" title="v-LazyLoad"></a>v-LazyLoad</h3><p>背景：在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。</p>
<p>需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。</p>
<p>思路：</p>
<ol>
<li>图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的</li>
<li>拿到所有的图片 Dom ，遍历每个图片判断当前图片是否到了可视区范围内</li>
<li>如果到了就设置图片的 src 属性，否则显示默认图片</li>
</ol>
<p>图片懒加载有两种方式可以实现，一是绑定 srcoll 事件进行监听，二是使用 IntersectionObserver 判断图片是否到了可视区域，但是有浏览器兼容性问题。</p>
<p>下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 IntersectionObserver API，如果支持就使用 IntersectionObserver 实现懒加载，否则则使用 srcoll 事件监听 + 节流的方法实现。</p>
<pre><code>const LazyLoad = {
  // install方法
  install(Vue, options) {
    const defaultSrc = options.default
    Vue.directive(&apos;lazy&apos;, {
      bind(el, binding) {
        LazyLoad.init(el, binding.value, defaultSrc)
      },
      inserted(el) {
        if (IntersectionObserver) {
          LazyLoad.observe(el)
        } else {
          LazyLoad.listenerScroll(el)
        }
      },
    })
  },
  // 初始化
  init(el, val, def) {
    el.setAttribute(&apos;data-src&apos;, val)
    el.setAttribute(&apos;src&apos;, def)
  },
  // 利用IntersectionObserver监听el
  observe(el) {
    var io = new IntersectionObserver((entries) =&gt; {
      const realSrc = el.dataset.src
      if (entries[0].isIntersecting) {
        if (realSrc) {
          el.src = realSrc
          el.removeAttribute(&apos;data-src&apos;)
        }
      }
    })
    io.observe(el)
  },
  // 监听scroll事件
  listenerScroll(el) {
    const handler = LazyLoad.throttle(LazyLoad.load, 300)
    LazyLoad.load(el)
    window.addEventListener(&apos;scroll&apos;, () =&gt; {
      handler(el)
    })
  },
  // 加载真实图片
  load(el) {
    const windowHeight = document.documentElement.clientHeight
    const elTop = el.getBoundingClientRect().top
    const elBtm = el.getBoundingClientRect().bottom
    const realSrc = el.dataset.src
    if (elTop - windowHeight &lt; 0 &amp;&amp; elBtm &gt; 0) {
      if (realSrc) {
        el.src = realSrc
        el.removeAttribute(&apos;data-src&apos;)
      }
    }
  },
  // 节流
  throttle(fn, delay) {
    let timer
    let prevTime
    return function (...args) {
      const currTime = Date.now()
      const context = this
      if (!prevTime) prevTime = currTime
      clearTimeout(timer)

      if (currTime - prevTime &gt; delay) {
        prevTime = currTime
        fn.apply(context, args)
        clearTimeout(timer)
        return
      }

      timer = setTimeout(function () {
        prevTime = Date.now()
        timer = null
        fn.apply(context, args)
      }, delay)
    }
  },
}

export default LazyLoad</code></pre><p>使用，将组件内 标签的 src 换成 v-LazyLoad</p>
<pre><code>&lt;img v-LazyLoad=&quot;xxx.jpg&quot; /&gt;</code></pre><h3 id="v-permission"><a href="#v-permission" class="headerlink" title="v-permission"></a>v-permission</h3><p>背景：在一些后台管理系统，我们可能需要根据用户角色进行一些操作权限的判断，很多时候我们都是粗暴地给一个元素添加 v-if / v-show 来进行显示隐藏，但如果判断条件繁琐且多个地方需要判断，这种方式的代码不仅不优雅而且冗余。针对这种情况，我们可以通过全局自定义指令来处理。</p>
<p>需求：自定义一个权限指令，对需要权限判断的 Dom 进行显示隐藏。</p>
<p>思路：</p>
<ol>
<li>自定义一个权限数组</li>
<li>判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom</li>
</ol>
<pre><code>function checkArray(key) {
  let arr = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]
  let index = arr.indexOf(key)
  if (index &gt; -1) {
    return true // 有权限
  } else {
    return false // 无权限
  }
}

const permission = {
  inserted: function (el, binding) {
    let permission = binding.value // 获取到 v-permission的值
    if (permission) {
      let hasPermission = checkArray(permission)
      if (!hasPermission) {
        // 没有权限 移除Dom元素
        el.parentNode &amp;&amp; el.parentNode.removeChild(el)
      }
    }
  },
}

export default permission</code></pre><p>使用：给 v-permission 赋值判断即可</p>
<pre><code>&lt;div class=&quot;btns&quot;&gt;
  &lt;!-- 显示 --&gt;
  &lt;button v-permission=&quot;&apos;1&apos;&quot;&gt;权限按钮1&lt;/button&gt;
  &lt;!-- 不显示 --&gt;
  &lt;button v-permission=&quot;&apos;10&apos;&quot;&gt;权限按钮2&lt;/button&gt;
&lt;/div&gt;</code></pre><h3 id="vue-waterMarker"><a href="#vue-waterMarker" class="headerlink" title="vue-waterMarker"></a>vue-waterMarker</h3><p>需求：给整个页面添加背景水印</p>
<p>思路：</p>
<ol>
<li>使用 canvas 特性生成 base64 格式的图片文件，设置其字体大小，颜色等。</li>
<li>将其设置为背景图片，从而实现页面或组件水印效果</li>
</ol>
<pre><code>function addWaterMarker(str, parentNode, font, textColor) {
  // 水印文字，父元素，字体，文字颜色
  var can = document.createElement(&apos;canvas&apos;)
  parentNode.appendChild(can)
  can.width = 200
  can.height = 150
  can.style.display = &apos;none&apos;
  var cans = can.getContext(&apos;2d&apos;)
  cans.rotate((-20 * Math.PI) / 180)
  cans.font = font || &apos;16px Microsoft JhengHei&apos;
  cans.fillStyle = textColor || &apos;rgba(180, 180, 180, 0.3)&apos;
  cans.textAlign = &apos;left&apos;
  cans.textBaseline = &apos;Middle&apos;
  cans.fillText(str, can.width / 10, can.height / 2)
  parentNode.style.backgroundImage = &apos;url(&apos; + can.toDataURL(&apos;image/png&apos;) + &apos;)&apos;
}

const waterMarker = {
  bind: function (el, binding) {
    addWaterMarker(binding.value.text, el, binding.value.font, binding.value.textColor)
  },
}

export default waterMarker</code></pre><p>使用，设置水印文案，颜色，字体大小即可</p>
<pre><code>&lt;template&gt;
  &lt;div v-waterMarker=&quot;{text:&apos;lzg版权所有&apos;,textColor:&apos;rgba(180, 180, 180, 0.4)&apos;}&quot;&gt;&lt;/div&gt;
&lt;/template&gt;</code></pre><h3 id="v-draggable"><a href="#v-draggable" class="headerlink" title="v-draggable"></a>v-draggable</h3><p>需求：实现一个拖拽指令，可在页面可视区域任意拖拽元素。</p>
<p>思路：</p>
<ol>
<li>设置需要拖拽的元素为相对定位，其父元素为绝对定位。</li>
<li>鼠标按下(onmousedown)时记录目标元素当前的 left 和 top 值。</li>
<li>鼠标移动(onmousemove)时计算每次移动的横向距离和纵向距离的变化值，并改变元素的 left 和 top 值</li>
<li>鼠标松开(onmouseup)时完成一次拖拽</li>
</ol>
<pre><code>const draggable = {
  inserted: function (el) {
    el.style.cursor = &apos;move&apos;
    el.onmousedown = function (e) {
      let disx = e.pageX - el.offsetLeft
      let disy = e.pageY - el.offsetTop
      document.onmousemove = function (e) {
        let x = e.pageX - disx
        let y = e.pageY - disy
        let maxX = document.body.clientWidth - parseInt(window.getComputedStyle(el).width)
        let maxY = document.body.clientHeight - parseInt(window.getComputedStyle(el).height)
        if (x &lt; 0) {
          x = 0
        } else if (x &gt; maxX) {
          x = maxX
        }

        if (y &lt; 0) {
          y = 0
        } else if (y &gt; maxY) {
          y = maxY
        }

        el.style.left = x + &apos;px&apos;
        el.style.top = y + &apos;px&apos;
      }
      document.onmouseup = function () {
        document.onmousemove = document.onmouseup = null
      }
    }
  },
}
export default draggable</code></pre><p>使用: 在 Dom 上加上 v-draggable 即可</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;el-dialog&quot; v-draggable&gt;&lt;/div&gt;
&lt;/template&gt;</code></pre><p>  所有指令源码地址 <a href="https://github.com/Michael-lzg/v-directives" target="_blank" rel="noopener">github.com/Michael-lzg…</a></p>
<p>原作者姓名： lzg9527<br>原出处：segmentfault<br>原文链接：<a href="https://segmentfault.com/a/1190000038475001" target="_blank" rel="noopener">分享8个非常实用的Vue自定义指令_个人文章 - SegmentFault 思否</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员必须掌握的英语单词</title>
    <url>/posts/1480820541.html</url>
    <content><![CDATA[<p>application 应用程式 应用、应用程序</p>
<p>application framework 应用程式框架、应用框架 应用程序框架</p>
<p>architecture 架构、系统架构 体系结构</p>
<p>argument 引数（传给函式的值）。叁见 parameter 叁数、实质叁数、实叁、自变量</p>
<p>array 阵列 数组</p>
<p>arrow operator arrow（箭头）运算子 箭头操作符</p>
<p>assembly 装配件</p>
<p>assembly language 组合语言 汇编语言</p>
<p>assert(ion) 断言</p>
<p>assign 指派、指定、设值、赋值 赋值</p>
<p>assignment 指派、指定 赋值、分配</p>
<p>assignment operator 指派（赋值）运算子 = 赋值操作符</p>
<p>associated 相应的、相关的 相关的、关联、相应的</p>
<p>associative container 关联式容器（对应 sequential container） 关联式容器</p>
<p>atomic 不可分割的 原子的</p>
<p>attribute 属性 属性、特性</p>
<p>audio 音讯 音频</p>
<p>A.I. 人工智慧 人工智能</p>
<p>background 背景 背景（用於图形着色） 后台（用於行程）</p>
<p>backward compatible 回溯相容 向下兼容</p>
<p>bandwidth 频宽 带宽</p>
<p>base class 基础类别 基类</p>
<p>base type 基础型别 (等同於 base class)</p>
<p>batch 批次（意思是整批作业） 批处理</p>
<p>benefit 利益 收益</p>
<p>best viable function 最佳可行函式 最佳可行函式 （从 viable functions 中挑出的最佳吻合者）</p>
<p>binary search 二分搜寻法 二分查找</p>
<p>binary tree 二元树 二叉树</p>
<p>binary function 二元函式 双叁函数</p>
<p>binary operator 二元运算子 二元操作符</p>
<p>binding 系结 绑定</p>
<p>bit 位元 位</p>
<p>bit field 位元栏 位域</p>
<p>bitmap 位元图 位图</p>
<p>bitwise 以 bit 为单元逐一┅</p>
<p>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝</p>
<p>block 区块,区段 块、区块、语句块</p>
<p>boolean 布林值（真假值，true 或 false） 布尔值</p>
<p>border 边框、框线 边框</p>
<p>brace(curly brace) 大括弧、大括号 花括弧、花括号</p>
<p>bracket(square brakcet) 中括弧、中括号 方括弧、方括号</p>
<p>breakpoint 中断点 断点</p>
<p>build 建造、构筑、建置（MS 用语）</p>
<p>build－in 内建 内置</p>
<p>bus 汇流排 总线</p>
<p>business 商务,业务 业务</p>
<p>buttons 按钮 按钮</p>
<p>byte 位元组（由 8 bits 组成） 字节</p>
<p>cache 快取 高速缓存</p>
<p>call 呼叫、叫用 调用</p>
<p>callback 回呼 回调</p>
<p>call operator call（函式呼叫）运算子调用操作符 ###### （同 function call operator）</p>
<p>candidate function 候选函式 候选函数 ###### （在函式多载决议程序中出现的候选函式）</p>
<p>chain 串链（例 chain of function calls） 链</p>
<p>character 字元 字符</p>
<p>check box 核取方块 (i.e. check button) 复选框</p>
<p>checked exception 可控式异常(Java)</p>
<p>check button 方钮 (i.e. check box) 复选按钮</p>
<p>child class 子类别（或称为derived class, subtype） 子类</p>
<p>class 类别 类</p>
<p>class body 类别本体 类体</p>
<p>class declaration 类别宣告、类别宣告式 类声明</p>
<p>class definition 类别定义、类别定义式 类定义</p>
<p>class derivation list 类别衍化列 类继承列表</p>
<p>class head 类别表头 类头</p>
<p>class hierarchy 类别继承体系, 类别阶层 类层次体系</p>
<p>class library 类别程式库、类别库 类库</p>
<p>class template 类别模板、类别范本 类模板</p>
<p>class template partial specializations ###### 类别模板偏特化 类模板部分特化</p>
<p>class template specializations ###### 类别模板特化 类模板特化</p>
<p>cleanup 清理、善后 清理、清除</p>
<p>client 客端、客户端、客户 客户</p>
<p>client－server 主从架构 客户/服务器</p>
<p>clipboard 剪贴簿 剪贴板</p>
<p>clone 复制 克隆</p>
<p>collection 群集 集合</p>
<p>combo box 复合方块、复合框 组合框</p>
<p>command line 命令列 命令行 (系统文字模式下的整行执行命令)</p>
<p>communication 通讯 通讯</p>
<p>compatible 相容 兼容</p>
<p>compile time 编译期 编译期、编译时</p>
<p>compiler 编译器 编译器</p>
<p>component 组件 组件</p>
<p>composition 复合、合成、组合 组合</p>
<p>computer 电脑、计算机 计算机、电脑</p>
<p>concept 概念 概念</p>
<p>concrete 具象的 实在的</p>
<p>concurrent 并行 并发</p>
<p>configuration 组态 配置</p>
<p>connection 连接，连线（网络,资料库） 连接</p>
<p>constraint 约束（条件）</p>
<p>construct 构件 构件</p>
<p>container 容器 容器 ###### （存放资料的某种结构如 list, vector…）</p>
<p>containment 内含 包容</p>
<p>context 背景关系、周遭环境、上下脉络 环境、上下文</p>
<p>control 控制元件、控件 控件</p>
<p>console 主控台 控制台</p>
<p>const 常数（constant 的缩写，C++ 关键字）</p>
<p>constant 常数（相对於 variable） 常量</p>
<p>constructor（ctor） 建构式 构造函数 ###### （与class 同名的一种 member functions）</p>
<p>copy (v) 复制、拷贝 拷贝</p>
<p>copy (n) 复件, 副本</p>
<p>cover 涵盖 覆盖</p>
<p>create 创建、建立、产生、生成 创建</p>
<p>creation 产生、生成 创建</p>
<p>cursor 游标 光标</p>
<p>custom 订制、自定 定制</p>
<p>data 资料 数据</p>
<p>database 资料库 数据库</p>
<p>database schema 数据库结构纲目</p>
<p>data member 资料成员、成员变数 数据成员、成员变量</p>
<p>data structure 资料结构 数据结构</p>
<p>datagram 资料元 数据报文</p>
<p>dead lock 死结 死锁</p>
<p>debug 除错 调试</p>
<p>debugger 除错器 调试器</p>
<p>declaration 宣告、宣告式 声明</p>
<p>deduction 推导（例：template argument deduction） 推导、推断</p>
<p>default 预设 缺省、默认</p>
<p>defer 延缓 推迟</p>
<p>define 定义 预定义</p>
<p>definition 定义、定义区、定义式 定义</p>
<p>delegate 委派、委托、委任 委托</p>
<p>delegation （同上）</p>
<p>demarshal 反编列 散集</p>
<p>dereference 提领（取出指标所指物体的内容） 解叁考</p>
<p>dereference operator dereference（提领）运算子 * 解叁考操作符</p>
<p>derived class 衍生类别 派生类</p>
<p>design by contract 契约式设计</p>
<p>design pattern 设计范式、设计样式 设计模式 ※ 最近我比较喜欢「设计范式」一词</p>
<p>destroy 摧毁、销毁</p>
<p>destructor 解构式 析构函数</p>
<p>device 装置、设备 设备</p>
<p>dialog 对话窗、对话盒 对话框</p>
<p>directive 指令（例：using directive） (编译)指示符</p>
<p>directory 目录 目录</p>
<p>disk 碟 盘</p>
<p>dispatch 分派 分派</p>
<p>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)</p>
<p>document 文件 文档</p>
<p>dot operator dot（句点）运算子 . (圆)点操作符</p>
<p>driver 驱动程式 驱动（程序）</p>
<p>dynamic binding 动态系结 动态绑定</p>
<p>efficiency 效率 效率</p>
<p>efficient 高效 高效</p>
<p>end user 终端用户</p>
<p>entity 物体 实体、物体</p>
<p>encapsulation 封装 封装</p>
<p>enclosing class 外围类别（与巢状类别 nested class 有关）外围类</p>
<p>enum (enumeration) 列举（一种 C++ 资料型别） 枚举</p>
<p>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器</p>
<p>equal 相等 相等</p>
<p>equality 相等性 相等性</p>
<p>equality operator equality（等号）运算子 == 等号操作符</p>
<p>equivalence 等价性、等同性、对等性 等价性</p>
<p>equivalent 等价、等同、对等 等价</p>
<p>escape code 转义码 转义码</p>
<p>evaluate 评估、求值、核定 评估</p>
<p>event 事件 事件</p>
<p>event driven 事件驱动的 事件驱动的</p>
<p>exception 异常情况 异常</p>
<p>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明</p>
<p>exception handling 异常处理、异常处理机制 异常处理、异常处理机制</p>
<p>exception specification 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范</p>
<p>exit 退离（指离开函式时的那一个执行点） 退出</p>
<p>explicit 明白的、明显的、显式 显式</p>
<p>export 汇出 引出、导出</p>
<p>expression 运算式、算式 表达式</p>
<p>facility 设施、设备 设施、设备</p>
<p>feature 特性</p>
<p>field 栏位,资料栏（Java） 字段, 值域（Java）</p>
<p>file 档案 文件</p>
<p>firmware 韧体 固件</p>
<p>flag 旗标 标记</p>
<p>flash memory 快闪记忆体 闪存</p>
<p>flexibility 弹性 灵活性</p>
<p>flush 清理、扫清 刷新</p>
<p>font 字型 字体</p>
<p>form 表单（programming 用语） 窗体</p>
<p>formal parameter 形式叁数 形式叁数</p>
<p>forward declaration 前置宣告 前置声明</p>
<p>forwarding 转呼叫,转发 转发</p>
<p>forwarding function 转呼叫函式,转发函式 转发函数</p>
<p>fractal 碎形 分形</p>
<p>framework 框架 框架</p>
<p>full specialization 全特化（ref. partial specialization）</p>
<p>function 函式、函数 函数</p>
<p>function call operator 同 call operator</p>
<p>function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象</p>
<p>function overloaded resolution 函式多载决议程序 函数重载解决（方案）</p>
<p>functionality 功能、机能 功能</p>
<p>function template 函式模板、函式范本 函数模板</p>
<p>functor 仿函式 仿函式、函子</p>
<p>game 游戏 游戏</p>
<p>generate 生成</p>
<p>generic 泛型、一般化的 一般化的、通用的、泛化</p>
<p>generic algorithm 泛型演算法 通用算法</p>
<p>getter (相对於 setter) 取值函式</p>
<p>global 全域的（对应於 local） 全局的</p>
<p>global object 全域物件 全局对象</p>
<p>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符</p>
<p>group 群组</p>
<p>group box 群组方块 分组框</p>
<p>guard clause 卫述句 (Refactoring, p250) 卫语句</p>
<p>GUI 图形介面 图形界面</p>
<p>hand shaking 握手协商</p>
<p>handle 识别码、识别号、号码牌、权柄 句柄</p>
<p>handler 处理常式 处理函数</p>
<p>hard－coded 编死的 硬编码的</p>
<p>hard－copy 硬拷图 屏幕截图</p>
<p>hard disk 硬碟 硬盘</p>
<p>hardware 硬体 硬件</p>
<p>hash table 杂凑表 哈希表、散列表</p>
<p>header file 表头档、标头档 头文件</p>
<p>heap 堆积 堆</p>
<p>hierarchy 阶层体系 层次结构（体系）</p>
<p>hook 挂钩 钩子</p>
<p>hyperlink 超链结 超链接</p>
<p>icon 图示、图标 图标</p>
<p>IDE 整合开发环境 集成开发环境</p>
<p>identifier 识别字、识别符号 标识符</p>
<p>if and only if 若且唯若 当且仅当</p>
<p>Illinois 伊利诺 伊利诺斯</p>
<p>image 影像 图象</p>
<p>immediate base 直接的（紧临的）上层 base class。 直接上层基类</p>
<p>immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类</p>
<p>immutability 不变性</p>
<p>immutable 不可变（的）</p>
<p>implement 实作、实现 实现</p>
<p>implementation 实作品、实作体、实作码、实件 实现</p>
<p>implicit 隐喻的、暗自的、隐式 隐式</p>
<p>import 汇入 导入</p>
<p>increment operator 累加运算子 ++ 增加操作符</p>
<p>infinite loop 无穷回圈 无限循环</p>
<p>infinite recursive 无穷递回 无限递归</p>
<p>information 资讯 信息</p>
<p>infrastructure 公共基础建设</p>
<p>inheritance 继承、继承机制 继承、继承机制</p>
<p>inline 行内 内联</p>
<p>inline expansion 行内展开 内联展开</p>
<p>initialization 初始化（动作） 初始化</p>
<p>initialization list 初值列 初始值列表</p>
<p>initialize 初始化 初始化</p>
<p>inner class 内隐类别 内嵌类</p>
<p>instance 实体 实例 ###### （根据某种表述而实际产生的「东西」）</p>
<p>instantiated 具现化、实体化（常应用於 template） 实例化</p>
<p>instantiation 具现体、具现化实体（常应用於 template） 实例</p>
<p>integer (integral) 整数（的） 整型（的）</p>
<p>integrate 整合 集成</p>
<p>interacts 交谈、互动 交互</p>
<p>interface 介面 接口</p>
<p>for GUI 介面 界面</p>
<p>interpreter 直译器 解释器</p>
<p>invariants 恒常性,约束条件 约束条件</p>
<p>invoke 唤起 调用</p>
<p>iterate 迭代（回圈一个轮回一个轮回地进行） 迭代</p>
<p>exception 异常情况 异常</p>
<p>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3） 异常声明</p>
<p>exception handling 异常处理、异常处理机制 异常处理、异常处理机制</p>
<p>exception specification 异常规格（ref. C++ Primer 3/e, 11.4） 异常规范</p>
<p>exit 退离（指离开函式时的那一个执行点） 退出</p>
<p>explicit 明白的、明显的、显式 显式</p>
<p>export 汇出 引出、导出</p>
<p>expression 运算式、算式 表达式</p>
<p>facility 设施、设备 设施、设备</p>
<p>feature 特性</p>
<p>field 栏位,资料栏（Java） 字段, 值域（Java）</p>
<p>file 档案 文件</p>
<p>firmware 韧体 固件</p>
<p>flag 旗标 标记</p>
<p>flash memory 快闪记忆体 闪存</p>
<p>flexibility 弹性 灵活性</p>
<p>flush 清理、扫清 刷新</p>
<p>font 字型 字体</p>
<p>form 表单（programming 用语） 窗体</p>
<p>formal parameter 形式叁数 形式叁数</p>
<p>forward declaration 前置宣告 前置声明</p>
<p>forwarding 转呼叫,转发 转发</p>
<p>forwarding function 转呼叫函式,转发函式 转发函数</p>
<p>fractal 碎形 分形</p>
<p>framework 框架 框架</p>
<p>full specialization 全特化（ref. partial specialization）</p>
<p>function 函式、函数 函数</p>
<p>function call operator 同 call operator</p>
<p>function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象</p>
<p>function overloaded resolution 函式多载决议程序 函数重载解决（方案）</p>
<p>functionality 功能、机能 功能</p>
<p>function template 函式模板、函式范本 函数模板</p>
<p>functor 仿函式 仿函式、函子</p>
<p>game 游戏 游戏</p>
<p>generate 生成</p>
<p>generic 泛型、一般化的 一般化的、通用的、泛化</p>
<p>generic algorithm 泛型演算法 通用算法</p>
<p>getter (相对於 setter) 取值函式</p>
<p>global 全域的（对应於 local） 全局的</p>
<p>global object 全域物件 全局对象</p>
<p>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符</p>
<p>group 群组</p>
<p>group box 群组方块 分组框</p>
<p>guard clause 卫述句 (Refactoring, p250) 卫语句</p>
<p>GUI 图形介面 图形界面</p>
<p>hand shaking 握手协商</p>
<p>handle 识别码、识别号、号码牌、权柄 句柄</p>
<p>handler 处理常式 处理函数</p>
<p>hard－coded 编死的 硬编码的</p>
<p>hard－copy 硬拷图 屏幕截图</p>
<p>hard disk 硬碟 硬盘</p>
<p>hardware 硬体 硬件</p>
<p>hash table 杂凑表 哈希表、散列表</p>
<p>header file 表头档、标头档 头文件</p>
<p>heap 堆积 堆</p>
<p>hierarchy 阶层体系 层次结构（体系）</p>
<p>hook 挂钩 钩子</p>
<p>hyperlink 超链结 超链接</p>
<p>icon 图示、图标 图标</p>
<p>IDE 整合开发环境 集成开发环境</p>
<p>identifier 识别字、识别符号 标识符</p>
<p>if and only if 若且唯若 当且仅当</p>
<p>Illinois 伊利诺 伊利诺斯</p>
<p>image 影像 图象</p>
<p>immediate base 直接的（紧临的）上层 base class。 直接上层基类</p>
<p>immediate derived 直接的（紧临的）下层 derived class。 直接下层派生类</p>
<p>immutability 不变性</p>
<p>immutable 不可变（的）</p>
<p>implement 实作、实现 实现</p>
<p>implementation 实作品、实作体、实作码、实件 实现</p>
<p>implicit 隐喻的、暗自的、隐式 隐式</p>
<p>import 汇入 导入</p>
<p>increment operator 累加运算子 ++ 增加操作符</p>
<p>infinite loop 无穷回圈 无限循环</p>
<p>infinite recursive 无穷递回 无限递归</p>
<p>information 资讯 信息</p>
<p>infrastructure 公共基础建设</p>
<p>inheritance 继承、继承机制 继承、继承机制</p>
<p>inline 行内 内联</p>
<p>inline expansion 行内展开 内联展开</p>
<p>initialization 初始化（动作） 初始化</p>
<p>initialization list 初值列 初始值列表</p>
<p>initialize 初始化 初始化</p>
<p>inner class 内隐类别 内嵌类</p>
<p>instance 实体 实例 ###### （根据某种表述而实际产生的「东西」）</p>
<p>instantiated 具现化、实体化（常应用於 template） 实例化</p>
<p>instantiation 具现体、具现化实体（常应用於 template） 实例</p>
<p>integer (integral) 整数（的） 整型（的）</p>
<p>integrate 整合 集成</p>
<p>interacts 交谈、互动 交互</p>
<p>interface 介面 接口</p>
<p>for GUI 介面 界面</p>
<p>interpreter 直译器 解释器</p>
<p>invariants 恒常性,约束条件 约束条件</p>
<p>invoke 唤起 调用</p>
<p>iterate 迭代（回圈一个轮回一个轮回地进行） 迭代</p>
<p>iterative 反覆的，迭代的</p>
<p>iterator 迭代器（一种泛型指标） 迭代器</p>
<p>iteration 迭代（回圈每次轮回称为一个 iteration） 迭代</p>
<p>item 项目、条款 项、条款、项目</p>
<p>laser 雷射 激光</p>
<p>level 阶 层 (级) 例 high level 高阶 高层</p>
<p>library 程式库、函式库 库、函数库</p>
<p>lifetime 生命期、寿命 生命期、寿命</p>
<p>link 联结、连结 连接,链接</p>
<p>linker 联结器、连结器 连接器</p>
<p>literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数</p>
<p>list 串列（linked－list） 列表、表、链表</p>
<p>list box 列表方块、列表框 列表框</p>
<p>load 载入 装载</p>
<p>loader 载入器 装载器、载入器</p>
<p>local 区域的（对应於 global） 局部的</p>
<p>local object 区域物件 局部对象</p>
<p>lock 机锁</p>
<p>loop 回圈 循环</p>
<p>lvalue 左值 左值</p>
<p>macro 巨集 宏</p>
<p>magic number 魔术数字 魔法数</p>
<p>maintain 维护 维护</p>
<p>manipulator 操纵器（iostream 预先定义的一种东西） 操纵器</p>
<p>marshal 编列 列集 叁考 demarshal</p>
<p>mechanism 机制 机制</p>
<p>member 成员 成员</p>
<p>member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符</p>
<p>member function 成员函式 成员函数</p>
<p>member initialization list 成员初值列 成员初始值列表</p>
<p>memberwise 以 member 为单元┅、members 逐一┅ 以成员为单位</p>
<p>memberwise copy 以 members 为单元逐一复制</p>
<p>memory 记忆体 内存</p>
<p>menu 表单、选单 菜单</p>
<p>message 讯息 消息</p>
<p>message based 以讯息为基础的 基於消息的</p>
<p>message loop 讯息回圈 消息环</p>
<p>method (java) 方法、行为、函式 方法</p>
<p>meta－ 超－ 元－ 例 meta－programming 超编程 元编程</p>
<p>micro 微 微</p>
<p>middleware 中介层 中间件</p>
<p>modeling 模塑</p>
<p>modeling language 塑模语言，建模语言</p>
<p>modem 数据机 调制解调器</p>
<p>module 模组 模块</p>
<p>modifier 饰词 修饰符</p>
<p>most derived class 最末层衍生类别 最底层的派生类</p>
<p>mouse 滑鼠 鼠标</p>
<p>mutable 可变的 可变的</p>
<p>multi－tasking 多工 多任务</p>
<p>namespace 命名空间 名字空间、命名空间</p>
<p>native 原生的 本地的、固有的</p>
<p>nested class 巢状类别 嵌套类</p>
<p>network 网路 网络</p>
<p>network card 网路卡 网卡</p>
<p>object 物件 对象</p>
<p>object based 以物件为基础的 基於对象的</p>
<p>object file 目的档 目标文件</p>
<p>object model 物件模型 对象模型</p>
<p>object oriented 物件导向的 面向对象的</p>
<p>online 线上 在线</p>
<p>opaque 不透明的</p>
<p>operand 运算元 操作数</p>
<p>operating system (OS) 作业系统 操作系统</p>
<p>operation 操作、操作行为 操作</p>
<p>operator 运算子 操作符、运算符</p>
<p>option 选项，可选方案 选项</p>
<p>ordinary 常规的 常规的</p>
<p>overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）</p>
<p>overhead 额外负担、额外开销 额外开销</p>
<p>overload 多载化、多载化、重载 重载</p>
<p>overloaded function 多载化函式 重载的函数</p>
<p>overloaded operator 多载化运算子 被重载的操作符</p>
<p>overloaded set 多载集合 重载集合</p>
<p>override 改写、覆写 重载、改写、重新定义 ###### （在 derived class 中重新定义虚拟函式</p>
<p>package 套件 包</p>
<p>pair 对组</p>
<p>palette 调色盘、组件盘、工具箱</p>
<p>pane 窗格 窗格 ###### （有时为嵌板之意，例 Java Content Pane）</p>
<p>parallel 平行 并行</p>
<p>parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁</p>
<p>parameter list 叁数列 叁数列表</p>
<p>parent class 父类别（或称 base class） 父类</p>
<p>parentheses 小括弧、小括号 圆括弧、圆括号</p>
<p>parse 解析 解析</p>
<p>part 零件 部件</p>
<p>partial specialization 偏特化（ref. C++ Primer 3/e, 16.10） 局部特化 ###### （ref. full specialization）</p>
<p>pass by address 传址（函式引数的传递方式）（非正式用语）传地址</p>
<p>pass by reference 传址（函式引数的一种传递方式） 传地址, 按引用传递</p>
<p>pass by value 传值（函式引数的一种传递方式） 按值传递</p>
<p>pattern 范式、样式 模式</p>
<p>performance 效率、性能兼而有之 性能</p>
<p>persistence 永续性 持久性</p>
<p>pixel 图素、像素 像素</p>
<p>placement delete ref. C++ Primer 3/e, 15.8.2</p>
<p>placement new ref. C++ Primer 3/e, 15.8.2</p>
<p>platform 平台 平台</p>
<p>pointer 指标 指针 址位器（和址叁器 reference 形成对映，满好）</p>
<p>poll 轮询 轮询</p>
<p>polymorphism 多型 多态</p>
<p>pop up 冒起式、弹出式 弹出式</p>
<p>port 埠 端口</p>
<p>postfix 后置式、后序式 后置式</p>
<p>precedence 优先序（通常用於运算子的优先执行次序）</p>
<p>prefix 前置式、前序式 前置式</p>
<p>preprocessor 前处理器 预处理器</p>
<p>prime 质数 素数</p>
<p>primitive type 基本型别 (不同於 base class,基础类别)</p>
<p>print 列印 打印</p>
<p>printer 印表机 打印机</p>
<p>priority 优先权 (通常用於执行绪获得 CPU 时间的优先次序）</p>
<p>procedure 程序 过程</p>
<p>procedural 程序性的、程序式的 过程式的、过程化的</p>
<p>process 行程 进程</p>
<p>profile 评测 评测</p>
<p>profiler 效能（效率）评测器 效能（性能）评测器</p>
<p>programmer 程式员 程序员</p>
<p>programming 编程、程式设计、程式化 编程</p>
<p>progress bar 进度指示器 进度指示器</p>
<p>project 专案 项目、工程</p>
<p>property 属性</p>
<p>protocol 协定 协议</p>
<p>pseudo code 假码、虚拟码、伪码 伪码</p>
<p>qualified 经过资格修饰（例如加上 scope 运算子） 限定</p>
<p>qualifier 资格修饰词、饰词 限定修饰词</p>
<p>quality 品质 质量</p>
<p>queue 伫列 队列</p>
<p>radian 径度 弧度</p>
<p>radio button 圆钮 单选按钮</p>
<p>raise 引发（常用来表示发出一个 exception） 引起、引发</p>
<p>random number 随机数、乱数 随机数</p>
<p>range 范围、区间（用於 STL 时） 范围、区间</p>
<p>rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级</p>
<p>raw 生鲜的、未经处理的 未经处理的</p>
<p>record 记录 记录</p>
<p>recordset 记录集 记录集</p>
<p>recursive 递回 递归</p>
<p>re－direction 重导向 重定向</p>
<p>refactoring 重构、重整 重构</p>
<p>refer 取用 叁考</p>
<p>refer to 指向、指涉、指代</p>
<p>reference （C++ 中类似指标的东西，相当於 “化身”） 引用、叁考 址叁器, see pointer</p>
<p>register 暂存器 寄存器</p>
<p>reflection 反射 反射、映像</p>
<p>relational database 关联式资料库 关系数据库</p>
<p>represent 表述，表现 表述，表现</p>
<p>resolve 决议（为算式中的符号名称寻找 解析 对应之宣告式的过程）</p>
<p>resolution 决议程序、决议过程 解析过程</p>
<p>resolution 解析度 分辨率</p>
<p>restriction 局限</p>
<p>return 传回、回返 返回</p>
<p>return type 回返型别 返回类型</p>
<p>return value 回返值 返回值</p>
<p>robust 强固、稳健 健壮</p>
<p>robustness 强固性、稳健性 健壮性</p>
<p>routine 常式 例程</p>
<p>runtime 执行期 运行期、运行时</p>
<p>common language runtime (CLR) 译为「通用语言执行层」</p>
<p>rvalue 右值 右值</p>
<p>save 储存 存储</p>
<p>schedule 排程 调度</p>
<p>scheduler 排程器 调度程序</p>
<p>scheme 结构纲目、组织纲目</p>
<p>scroll bar 卷轴 滚动条</p>
<p>scope 生存空间、生存范围、范畴、作用域 生存空间</p>
<p>scope operator 生存空间（范围决议）运算子 :: 生存空间操作符</p>
<p>scope resolution operator 生存空间决议运算子 生存空间解析操作符 ###### （与scope operator同）</p>
<p>screen 萤幕 屏幕</p>
<p>search 搜寻 查找</p>
<p>semantics 语意 语义</p>
<p>sequential container 序列式容器 顺序式容器 ###### （对应於 associative container）</p>
<p>server 伺服器、伺服端 服务器、服务端</p>
<p>serial 串行</p>
<p>serialization 次第读写,序列化 序列化 (serialize)</p>
<p>setter (相对於 getter) 设值函式</p>
<p>signal 信号</p>
<p>signature 标记式、签名式、署名式 签名</p>
<p>slider 滚轴 滑块</p>
<p>slot 条孔、槽 槽</p>
<p>smart pointer 灵巧指标、精灵指标 智能指针</p>
<p>snapshot 萤幕快照（图） 屏幕截图</p>
<p>specialization 特殊化、特殊化定义、特殊化宣告 特化</p>
<p>specification 规格 规格、规范</p>
<p>splitter 分裂视窗 切分窗口</p>
<p>software 软体 软件</p>
<p>solution 解法,解决方案 方案</p>
<p>source 原始码 源码、源代码</p>
<p>stack 堆叠 栈</p>
<p>stack unwinding 堆叠辗转开解（此词用於 exception 主题） 栈辗转开解 *</p>
<p>standard library 标准程式库</p>
<p>standard template library 标准模板程式库</p>
<p>statement 述句 语句、声明</p>
<p>status bar 状态列、状态栏 状态条</p>
<p>STL 见 standard template library</p>
<p>stream 资料流、串流 流</p>
<p>string 字串 字符串</p>
<p>subroutine</p>
<p>subscript operator 下标运算子 [ ] 下标操作符</p>
<p>subtype 子型别 子类型</p>
<p>support 支援 支持</p>
<p>suspend 虚悬 挂起</p>
<p>symbol 符号 记号</p>
<p>syntax 语法 语法</p>
<p>tag 标签 标记 索引标签,页签</p>
<p>target 标的（例 target pointer：标的指标） 目标</p>
<p>task switch 工作切换 任务切换</p>
<p>template 模板、范本 模板</p>
<p>template argument deduction 模板引数推导 模板叁数推导</p>
<p>template explicit specialization 模板显式特化（版本） 模板显式特化</p>
<p>template parameter 模板叁数 模板叁数</p>
<p>temporary object 暂时物件 临时对象</p>
<p>text 文字 文本</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置教程</title>
    <url>/posts/4012101422.html</url>
    <content><![CDATA[<h3 id="Nginx-使用教程"><a href="#Nginx-使用教程" class="headerlink" title="Nginx 使用教程"></a>Nginx 使用教程</h3><h4 id="安装编译工具及库文件"><a href="#安装编译工具及库文件" class="headerlink" title="安装编译工具及库文件"></a>安装编译工具及库文件</h4><pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</code></pre><h4 id="安装-PCRE"><a href="#安装-PCRE" class="headerlink" title="安装 PCRE"></a>安装 PCRE</h4><p>PCRE库支持正则表达式。如果配置文件nginx.conf中使用了正则表达式，那么在编译Nginx时就必须把PCRE库编译进Nginx，因为Nginx的HTTP模块需要靠它来解析正则表达式。另外，pcre-devel是使用PCRE做二次开发时所需要的开发库，包括头文件等，这也是编译Nginx所必须使用的。</p>
<p>  <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz" target="_blank" rel="noopener">下载 PCRE 安装包</a></p>
<ol>
<li>我是使用xftp传输到服务器目录/usr/local/src/</li>
<li>解压安装包<ul>
<li>tar zxvf pcre-8.35.tar.gz</li>
</ul>
</li>
<li>进入安装目录，编译安装<ul>
<li>cd pcre-8.35</li>
<li>./configure</li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li>查看pcre版本<ul>
<li>pcre-config –version</li>
</ul>
</li>
</ol>
<h4 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><ol>
<li><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">Nginx官网下载 </a></li>
<li>传输到服务器目录/usr/local/src/</li>
<li>解压安装包<ul>
<li>tar zxvf nginx-1.16.1.tar.gz</li>
</ul>
</li>
<li>进入安装目录，编译安装</li>
</ol>
<pre><code>cd nginx-1.16.1
./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35
make &amp;&amp; make install</code></pre><ol start="4">
<li>查看版本<ul>
<li>/usr/local/webserver/nginx/sbin/nginx -v</li>
</ul>
</li>
<li>软连接，做全局命令<ul>
<li>ln -s /usr/local/webserver/nginx/sbin/nginx /usr/local/bin/</li>
</ul>
</li>
</ol>
<h4 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h4><ol>
<li>配置nginx.conf ，修改/usr/local/webserver/nginx/conf/nginx.conf</li>
</ol>
<pre><code>user nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        /usr/local/webserver/nginx/nginx.pid;

events {
    worker_connections  1024;
}

http {
include       mime.types;
default_type  application/octet-stream;

#log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;
#&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;
#&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;

#access_log  logs/access.log  main;

sendfile        on;
#tcp_nopush     on;

#keepalive_timeout  0;
keepalive_timeout  65;

#gzip  on;
#gzip压缩功能设置
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_http_version 1.0;
gzip_comp_level 6;
gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;
gzip_vary on;

#http_proxy 设置
client_max_body_size 10m;
client_body_buffer_size 128k;
proxy_connect_timeout 75;
proxy_send_timeout 75;
proxy_read_timeout 75;
proxy_buffer_size 4k;
proxy_buffers 4 32k;
proxy_busy_buffers_size 64k;
proxy_temp_file_write_size 64k;
proxy_temp_path /usr/local/webserver/nginx/proxy_temp 1 2;
#下面是server虚拟主机的配置
server
  {
    listen 80;#监听端口
    server_name admin.haojie365.cn; #你的域名
  location / {
    proxy_pass http://localhost:8888; #转发的地址端口
    #允许cros跨域访问
    add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;
  }
  }
  server
  {
    listen 80;#监听端口
    server_name play.haojie365.cn;#域名
  root   /home/server/testnode/admin; #项目的目录地址
  index  index.html index.htm;
  }
}</code></pre><h4 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h4><ol>
<li>检查配置文件nginx.conf的正确性<ul>
<li>nginx -t</li>
</ul>
</li>
<li>启动nginx命令<ul>
<li>nginx</li>
</ul>
</li>
<li>从浏览器访问域名，看到welcome to nginx,就是配置成功</li>
<li>其他命令<ul>
<li>nginx -s reload # 重新载入配置文件</li>
<li>nginx -s reopen # 重启</li>
<li>nginx -s stop   # 停止</li>
</ul>
</li>
</ol>
<h4 id="Nginx启动成功，却访问不了"><a href="#Nginx启动成功，却访问不了" class="headerlink" title="Nginx启动成功，却访问不了"></a>Nginx启动成功，却访问不了</h4><ol>
<li>先查看nginx配置是否正确 <ul>
<li>nginx -t</li>
</ul>
</li>
<li>查看nginx是否启动成功<ul>
<li>ps -ef | grep nginx  #查看nginx端口</li>
</ul>
</li>
<li>如果是云服务器，配置服务器安全组，放开对应的端口</li>
<li>检查服务器对应的端口是否放开</li>
<li>检查防火墙是否开启，放开防火墙的端口<ul>
<li>/sbin/iptables -I INPUT -p tcp –dport 8011 -j ACCEPT #开启8011端口</li>
<li>/etc/rc.d/init.d/iptables save #保存配置</li>
<li>/etc/rc.d/init.d/iptables restart #重启服务</li>
<li>/etc/init.d/iptables status #查看端口是否已经开放</li>
</ul>
</li>
<li>查看端口是否放开<ul>
<li>telnet ip port</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>CenterOS7下mongoDB安装以及配置</title>
    <url>/posts/4092916722.html</url>
    <content><![CDATA[<h3 id="1-在mongDB官网下载mongoDB"><a href="#1-在mongDB官网下载mongoDB" class="headerlink" title="1.在mongDB官网下载mongoDB"></a>1.在mongDB官网下载mongoDB</h3><p>使用命令</p>
<pre><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.5.tgz </code></pre><h3 id="2-解归档"><a href="#2-解归档" class="headerlink" title="2.解归档"></a>2.解归档</h3><pre><code>gunzip mongodb-linux-x86_64-3.6.5.tgz</code></pre><h3 id="3-解压缩"><a href="#3-解压缩" class="headerlink" title="3.解压缩"></a>3.解压缩</h3><pre><code>tar -xvf mongodb-linux-x86_64-3.6.5.tar</code></pre><h3 id="4-将mongodb文件移动到-usr-local-文件夹下"><a href="#4-将mongodb文件移动到-usr-local-文件夹下" class="headerlink" title="4.将mongodb文件移动到/usr/local/文件夹下"></a>4.将mongodb文件移动到/usr/local/文件夹下</h3><pre><code>mv mongodb-linux-x86_64-3.6.5  /usr/local/mongodb</code></pre><h3 id="5-配置mongodb-conf"><a href="#5-配置mongodb-conf" class="headerlink" title="5.配置mongodb.conf"></a>5.配置mongodb.conf</h3><pre><code>cd /usr/local/mongodb
mkdir -p etc
cd etc
vim mongodb.conf</code></pre><h3 id="6-在mongodb-conf-写入以下内容"><a href="#6-在mongodb-conf-写入以下内容" class="headerlink" title="6.在mongodb.conf 写入以下内容"></a>6.在mongodb.conf 写入以下内容</h3><pre><code># idae - MongoDB config start

# 设置数据文件的存放目录（根据实际的db文件夹的路径填写）

dbpath = /usr/local/mongodb/db

# 设置日志文件的存放目录及其日志文件名（根据实际的logs文件夹的路径填写）

logpath = /usr/local/mongodb/logs/mongodb.log

# 设置端口号（默认的端口号是 27017）

port = 27017

# 设置为以守护进程的方式运行，即在后台运行
fork = true

nohttpinterface = true

# idae - MongoDB config end</code></pre><h3 id="7-进入用户主目录"><a href="#7-进入用户主目录" class="headerlink" title="7.进入用户主目录"></a>7.进入用户主目录</h3><pre><code>cd /</code></pre><h3 id="8-在根目录下创建data文件夹"><a href="#8-在根目录下创建data文件夹" class="headerlink" title="8.在根目录下创建data文件夹"></a>8.在根目录下创建data文件夹</h3><pre><code>mkdir data

cd data

mkdir db</code></pre><h3 id="9-给db文件授权"><a href="#9-给db文件授权" class="headerlink" title="9.给db文件授权"></a>9.给db文件授权</h3><pre><code>sudo chown -R $USER /data/db </code></pre><h3 id="10-配置环境变量"><a href="#10-配置环境变量" class="headerlink" title="10.配置环境变量"></a>10.配置环境变量</h3><pre><code>cd ~
跳转至用户目录下，然后对当前目录下的.bash_profile进行编辑
vim .bash_profile            
# 配置环境变量    
# 末尾添加 export PATH=&lt;source&gt;/bin:$PATH  
export PATH=/usr/local/mongodb/mongodb-linux-x86_64-3.6.5/bin:$PATH</code></pre><h3 id="11-运行配置文件"><a href="#11-运行配置文件" class="headerlink" title="11.运行配置文件"></a>11.运行配置文件</h3><pre><code>sudo chown -R $USER /data/db </code></pre><h3 id="12-进入在-usr-local-mongodb-bin目录下输入如下命令启动Mongo"><a href="#12-进入在-usr-local-mongodb-bin目录下输入如下命令启动Mongo" class="headerlink" title="12.进入在/usr/local/mongodb/bin目录下输入如下命令启动Mongo"></a>12.进入在/usr/local/mongodb/bin目录下输入如下命令启动Mongo</h3><pre><code>cd /usr/local/mongodb/bin
mongod 
以配置文件启动
mongod -f mongodb.conf</code></pre><h3 id="13-绑定私有IP"><a href="#13-绑定私有IP" class="headerlink" title="13.绑定私有IP"></a>13.绑定私有IP</h3><pre><code>mongod --bind_ip 私有IP  --quiet &amp; </code></pre><h3 id="14-绑定公网IP"><a href="#14-绑定公网IP" class="headerlink" title="14.绑定公网IP"></a>14.绑定公网IP</h3><pre><code>mongo --host 公网IP  --port 27017</code></pre><h3 id="15-关闭mongodb"><a href="#15-关闭mongodb" class="headerlink" title="15.关闭mongodb"></a>15.关闭mongodb</h3><pre><code>mongod --shutdown</code></pre><h3 id="16-创建数据库管理用户"><a href="#16-创建数据库管理用户" class="headerlink" title="16.创建数据库管理用户"></a>16.创建数据库管理用户</h3><pre><code>db.createUser({user:&apos;admin&apos;,pwd:&apos;123456&apos;,role:[{&quot;role&quot;:&quot;userAdminAnyDatabase&quot;,&quot;db&quot;:&quot;admin&quot;}]})</code></pre><h3 id="17-用户名密码连接数据库"><a href="#17-用户名密码连接数据库" class="headerlink" title="17.用户名密码连接数据库"></a>17.用户名密码连接数据库</h3><pre><code>mongodb://用户名:密码@111.231.195.137:27017/数据库名?authSource=admin</code></pre>]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>CenterOS</tag>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/posts/3611036983.html</url>
    <content><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h4><p><strong>ECMAScript通常看做JavaScript的标准化规范，实际上JavaScript是ECMAScript的扩展语言,ECMAScript只是提供了最基本的语法。</strong></p>
<p> <font color=LightCoral>JavaScript = ECMAScript + BOM + DOM</font></p>
<ul>
<li>2015年开始ES保持每年一个版本的迭代，并且开始按照年份命名。</li>
<li>相比于ES5.1的变化比较大</li>
<li>自此，标准命名规则发生变化</li>
<li>ES6泛指是2015之后的所有新标准，以后要看清楚是特指还是泛指</li>
</ul>
<h4 id="新特性的分类"><a href="#新特性的分类" class="headerlink" title="新特性的分类"></a>新特性的分类</h4><ul>
<li>解决原有语法上的一些问题或者不足</li>
<li>对原有语法进行增强</li>
<li>全新的对象、全新的方法、全新的功能</li>
<li>全新的数据类型和数据结构</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块状作用域</li>
<li>动态作用域</li>
</ol>
<table>
<thead>
<tr>
<th align="left">对象</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">global/window</td>
<td align="left">全局作用域</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">函数作用域（局部作用域）</td>
</tr>
<tr>
<td align="left">{}</td>
<td align="left">块状作用域（if语句，for语句）</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">动态作用域</td>
</tr>
</tbody></table>
<h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>在全局使用var定义的变量为全局变量</p>
<p>案例一：</p>
<pre><code>var abc = 1234
abcd = 2345

delete abc //false
console.log(abc) //1234
delete abcd //true
console.log(abcd) //abcd is not defined

// abc是一个全局对象，但是abcd不是全局变量，而是作为window对象的属性存在的，
// 但是因为window是全局对象，所以看上去它也具备全局属性，拥有全局作用域</code></pre><p>案例二：</p>
<pre><code>function test(){
    ab = 45
}
test()

console.log(ab) //45
//在函数内部没有使用var定义的变量，都挂载在window上，不是全局变量，但是拥有全局作用域</code></pre><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>在函数内部定义的变量，拥有函数作用域/局部作用域</p>
<pre><code>function test(){
    var a = 3
    return a + 4
}
console.log(test()) // 7 
console.log(a) //a is not defined</code></pre><p>如何让a在函数作用域中，但是某些值共享?</p>
<ol>
<li>return</li>
<li>闭包</li>
</ol>
<h4 id="块级作用域-ES6新增"><a href="#块级作用域-ES6新增" class="headerlink" title="块级作用域(ES6新增)"></a>块级作用域(ES6新增)</h4><p>ES5</p>
<pre><code>// ES5
function test(){
    var a = 3
    if (a === 3) {
        var b = 4
        console.log(&apos;abc&apos;)
    } else {
        console.log(&apos;abcd&apos;)
    }
    console.log(b)  // 4
    return a + 4
}

//在if的块中无法形成壁垒，在{}中定义的变量在外界还是可以使用的
//ES6将{}中的东西进行了独立

function test () {
    var a = 3
    function test2 () {
        var b = 4
        return a + b
    }
    return test2
}

/* test里面的变量对test2是共享的，a的值是可以取到的。
根据函数的作用域链：
执行test2中的函数，首先定义b，然后return中找a，没有找到就去上一个函数中找，找到了a
如果在test中找不到a，最后会一直找到window
*/ </code></pre><p>ES6</p>
<pre><code>function test(){
    var a = 3
    if (a === 3) {
        let b = 4
        console.log(&apos;abc&apos;)
    } else {
        console.log(&apos;abcd&apos;)
    }
    console.log(b)  // b is not defined
    return a + 4
}

// 如果想要使用块状作用域，但是此时不能用var，因为var有一个变量提升机制。
// 但凡看到了var，就会提升到当前作用域最顶层，所以只能使用let,const</code></pre><h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><p>this 是非常特殊的关键词标识符，在每个函数的作用域中被自动创建。<br>只能在执行阶段才能决定变量的作用域。</p>
<pre><code>window.a = 3
function test () {
    console.log(this.a)
}
test()  // 3
test.bind({ a:100 })()  // 100

// 因为this是一个动态指向，不是固定指向。所以我们称这个为动态作用域。
// bind是让函数动态绑定到一个对象上去，这个时候this指向对象本身，所以会导致同一个函数有不同的效果。</code></pre><h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ul>
<li>js采用词法（静态）作用域，因此开启动态作用域请借助bind,with,eval等。</li>
<li>bash采用的是动态作用域</li>
</ul>
<table>
<thead>
<tr>
<th align="left">静态作用域</th>
<th align="left">动态作用域</th>
</tr>
</thead>
<tbody><tr>
<td align="left">变量的作用域是在定义时决定而不是执行时决定，一般通过静态分析就能确定。</td>
<td align="left">只能在执行阶段才能决定变量的作用域。</td>
</tr>
</tbody></table>
<pre><code>// 经过验证，js默认采用静态作用域
// a 在foo调用的时候没有在当前函数作用域中找到，所以按照书写代码顺序往外层找，就是var a = 2，而不是取bar函数里面找
function foo() {
    console.log(a)  // 2
}

function bar() {
    var a = 3
    foo()
}

var a = 2
bar()</code></pre><h3 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p><strong>解决var存在的问题</strong></p>
<p>let的出现是为了解决一些var存在的问题</p>
<ul>
<li>同名变量，不在一个作用域，互不影响</li>
</ul>
<pre><code>// 下面两个i，虽然名字一样，但是不在一个作用域，所以互不影响
for (let i = 0; i &lt; 3; i++) {
    let i = &apos;foo&apos;
    console.log(i) // foo
}</code></pre><ul>
<li>解决循环嵌套计数器命名相同混乱的问题</li>
</ul>
<pre><code>const arr = [1, 2, 3, 4]
for(let i = 0; i &lt; 3; i++) {
    for(let i = 0; i &lt; 4 ; i++) {
        console.log(arr[i])
    }
}
// 1 2 3 4 1 2 3 4 1 2 3 4</code></pre><ul>
<li>解决计数器循环中有异步变量被改变的问题（解决原理：闭包</li>
</ul>
<pre><code>for (var i = 0; i &lt; 3; i++) {
    setTimeout(() =&gt; {
        console.log(i)
    }, 0)
}
// 输出三个3</code></pre><p><strong>特点</strong></p>
<ol>
<li>有块级作用域</li>
</ol>
<pre><code>{
    let a = 1
    console.log(a)
}
console.log(a) //a is not defined</code></pre><ol start="2">
<li>全局变量不能用过window（全局对象）访问</li>
</ol>
<pre><code>var b = 3
let c = 4
console.log(b, c) // 3,4
console.log(window.b, window.c) //3,undefined</code></pre><ol start="3">
<li>不能重复声明变量</li>
</ol>
<pre><code>var b = 3
let c = 4
console.log(b, c) // 3,4

var b = 4
console.log(b) //4

let c = 5  // Identifier &apos;c&apos; has already been declared c已经被声明
console.log(c)</code></pre><ol start="4">
<li>不会进行变量提升</li>
</ol>
<pre><code>function test() {
    console.log(a)
    let a = 1
}
test() // Cannot access &apos;a&apos; before initialization 不能在初始化之前调用</code></pre><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><strong>特点</strong></p>
<ol>
<li><p>所有let的属性都有</p>
</li>
<li><p>只能定义常量，不能被修改</p>
</li>
</ol>
<pre><code>cosnt a = 2
a = 3 //Assignment to constant variable 类型错误</code></pre><ol start="3">
<li>声明时必须初始化</li>
</ol>
<pre><code>const a //Missing initializer in const declaration  声明的时候缺少初始化
a = 2</code></pre><p><strong>为什么const定义对象，其属性可以改变，但是常量不可以?</strong></p>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动，对于简单类型的数据（数值，字符串，布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针指向的内存地址是固定的，至于它指向的内存地址中保存的数据结构是不是可变的，就完全不能控制了。因此将一个对象声明为常量要小心。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>不用var，主用const，遇到可变的使用let</p>
<h3 id="数据的重要功能【遍历、转换、生成、查找】"><a href="#数据的重要功能【遍历、转换、生成、查找】" class="headerlink" title="数据的重要功能【遍历、转换、生成、查找】"></a>数据的重要功能【遍历、转换、生成、查找】</h3><h4 id="ES5中遍历有多少种方法？"><a href="#ES5中遍历有多少种方法？" class="headerlink" title="ES5中遍历有多少种方法？"></a>ES5中遍历有多少种方法？</h4><pre><code>const arr = [1,2,3,4,5]</code></pre><ul>
<li>for 循环</li>
</ul>
<pre><code>for (let i = 0;i &lt; arr.length; i++) {
    console.log(arr[i]) // 1 2 3 4 5
}</code></pre><ul>
<li>forEach 数组遍历方法</li>
</ul>
<pre><code>arr.forEach(function(item){
    console.log(item) //1 2 3 4 5
})</code></pre><p>代码简洁上看，forEach比for循环写法要简洁。</p>
<p>但是forEach不支持reak和continue，每个元素必须遍历到</p>
<pre><code>// for循环可以使用break控制遍历停止
for (let i = 0;i &lt; arr.length; i++) {
    if(arr[i] === 2){
        break
    }
    console.log(arr[i]) // 1
}

// for循环可以使用continue控制遍历跳过
for (let i = 0;i &lt; arr.length; i++) {
    if(arr[i] === 2){
        continue
    }
    console.log(arr[i]) // 1 3 4 5
}

//forEach不支持break和continue
arr.forEach(function(item){
    if(item === 2) {
        break // or continue 都会报错 Unsyntactic break 语法不支持
    }
    console.log(item)
})

arr.forEach(function(item){
    if(item === 2) {
        return false //跳过本此循环 类似continue
    }
    console.log(item) // 1 3 4 5
})</code></pre><ul>
<li>every 数组遍历方法</li>
</ul>
<pre><code>arr.every(function(item){
    console.log(item) // 1
})
// every继不继续遍历取决于返回值，为true则继续遍历，false退出。默认是false
// 如果要全部遍历完成 需要返回true
arr.every(function(item){
    console.log(item)  // 1 2 3 4 5
    return true
})

// 可以通过返回的true or false 来控制循环
arr.every(function(item){
    if(item === 2) {
        return false //相当于for循环中的break
    }
    console.log(item)  // 1
    return true
})</code></pre><ul>
<li>for-in</li>
</ul>
<p>for-in本身是未object遍历的，而不是为数组。虽然可以遍历数组，但是有瑕疵。<br>for-in中可以使用continue和break，但是不支持写return，会报错Illegal return statement</p>
<pre><code>// 之所以数组可以用for-in取遍历
// 是因为1.数组是对象的一种 2.数组是可遍历的
for (let index in arr) {
    console.log(index, arr[index])
}
// 0 1
// 1 2
// 2 3
// 3 4
// 4 5


//瑕疵一：
// 因为arr是一个对象，所以可以定义属性并赋值
arr.a = 8
for (let index in arr) {
    console.log(index, arr[index])
}
// 再次进行遍历
// 0 1
// 1 2
// 2 3
// 3 4
// 4 5
// a 8  这个时候a不是索引，而是字符串，如果这里我们还是以为遍历之后只是返回索引就容易出现bug


//瑕疵二：
for(let index in arr) {
    if(index === 2) {
        continue
    }
    console.log(index, arr[index])
}
// 0 1
// 1 2
// 2 3
// 3 4
// 4 5
//为什么可以使用continue但是continue却没有起作用
//因为这个时候index是字符串而不是索引

//解决方法一：只判断值，不判断类型
for(let index in arr) {
    if(index == 2) {
        continue
    }
    console.log(index, arr[index])
}
// 0 1
// 1 2
// 3 4
// 4 5
//解决方法二：将index隐式转化成数字类型
for(let index in arr) {
    if(index * 1 === 2) {
        continue
    }
    console.log(index, arr[index])
}
// 0 1
// 1 2
// 3 4
// 4 5</code></pre><ul>
<li><p>for-of(ES6新增)</p>
<p>  // item不是下标，直接是值，且可以使用break终止循环<br>  for(let item of arr) {</p>
<pre><code>console.log(item) // 1 2 3 4 5</code></pre><p>  }</p>
</li>
</ul>
<p>为什么es6要新增一个for-of？</p>
<p>  要判断一个对象是不是可遍历的，不能说其是不是一个数组 or Object。<br>  ES6允许用户自定义数据结构，这种数据结构既不是数组，也不是Object，但是都是可遍历的。这种数据结构进行遍历，不能用数组的也不能用for-in，就需要新增一种for-of去遍历</p>
<p>举例子</p>
<pre><code>// 定义一个数据结构，想要遍历拿到类别中的最低值
const Price = {
    A: [1.5, 2.3, 4.5],
    B: [3, 4, 5],
    C: [0.5, 0.8, 1.2]
}

for (let key in Price) {
    console.log(key, Price[key])
    // [1.5, 2.3, 4.5]
    // [3, 4, 5]
    // [0.5, 0.8, 1.2]
}
// 使用for-in只能返回数组，无法直接把三个最低值遍历出来</code></pre><p>for-of不能直接遍历对象? —— 关于可迭代接口</p>
<p>for-of可以用来遍历Set结构和Map结构，但是不可以直接遍历object，因为其不是可遍历的对象，Iterable接口没有实现。<br>数组、Set和Map的原型对象上有迭代器，对象方法上面没有</p>
<p>我们调用一下数组上面的iterator方法</p>
<pre><code>const arr = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]
console.log(arr[Symbol.iterator]())
// 返回一个iterator的对象，其原型对象上面有next方法
// Array Iterator {}  
//  __proto__: Array Iterator
//    next: ƒ next()   
//    Symbol(Symbol.toStringTag): &quot;Array Iterator&quot;
//    __proto__: Object
const iterator = arr[Symbol.iterator]()

console.log(iterator.next()) // { value: &apos;foo&apos;, done: false }
console.log(iterator.next()) // { value: &apos;bar&apos;, done: false }
console.log(iterator.next()) // { value: &apos;baz&apos;, done: false }
console.log(iterator.next()) // { value: undefined, done: true }</code></pre><p>可以看到for-of内部的循环规则，里面有一个迭代器。只要对象可以实现Iterable接口就可以使用for-of进行循环。下面对一个对象进行可迭代改造。</p>
<ul>
<li>优势和缺点</li>
</ul>
<table>
<thead>
<tr>
<th align="left">循环方式</th>
<th align="left">优势</th>
<th align="left">缺点</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">for循环</td>
<td align="left">支持break和continue</td>
<td align="left"></td>
<td align="left">不支持return</td>
</tr>
<tr>
<td align="left">forEach</td>
<td align="left">写法比for简洁明了</td>
<td align="left">全部遍历，不支持break和continue</td>
<td align="left">return false相当于continue</td>
</tr>
<tr>
<td align="left">every</td>
<td align="left">可以支持类似for的break和continue</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">for-in</td>
<td align="left">可以遍历object</td>
<td align="left">遍历数组的时候存在瑕疵</td>
<td align="left">不支持return</td>
</tr>
<tr>
<td align="left">for-of(ES6新增)</td>
<td align="left">可以遍历除数组和object之外可遍历的数据结构，支持break和continue</td>
<td align="left"></td>
<td align="left">不支持return</td>
</tr>
</tbody></table>
<ul>
<li>return只能用在函数体内，出现在代码的任何地方都会报错</li>
</ul>
<h3 id="将伪数组转换成数组"><a href="#将伪数组转换成数组" class="headerlink" title="将伪数组转换成数组"></a>将伪数组转换成数组</h3><h4 id="什么是伪数组？"><a href="#什么是伪数组？" class="headerlink" title="什么是伪数组？"></a>什么是伪数组？</h4><p>简单理解：<br>具备一些数组的特性：可遍历、有长度。但是不能直接调用数组的API，类似于 arguments 和 DOM nodeList。</p>
<p>严格理解：</p>
<ol>
<li>按照索引方式存储数据</li>
<li>具备length属性<br>{0:’2’,1:’b’,length:2} 这种类型都可以称之为伪数组<br>为什么要将伪数组转换成数组？</li>
</ol>
<p>如果想要使用数组的API，就需要将伪数组转换为数组</p>
<ul>
<li>ES5的转换</li>
</ul>
<pre><code>let args = [].slice.call(arguments) //collection
// arguments 只能在函数体内使用
// ES6已经废弃arguments的使用
let imgs = [].slice.call(document.querySelectorAll(&apos;img&apos;)) // NodeList</code></pre><ul>
<li>ES6的转换</li>
</ul>
<pre><code>let args = Array.from(arguments)
let imgs = Array.from(document.querySelectorAll(&apos;img&apos;))</code></pre><p>大致说一下Array.from这个函数</p>
<pre><code>Array.from(arrayLike,mapFn,thisArg)
// 第一个参数：伪数组，必须
//第二个参数：遍历函数，非必须
//第三个函数：this对象，非必须</code></pre><p>举一个例子：<br>初始化一个长度为5的数组</p>
<pre><code>//ES5 
let array = Array(5)

array.forEach(function (item) {
    item = 1
})
console.log(array) // [empty × 5] forEach只会遍历存在的元素

//使用for循环可以遍历，但是依旧是先声明，后赋值
for (let i = 0, len = array.length; i &lt; len; i++) {
    array[i] = 1
}
console.log(array) // [1,1,1,1,1]

// 先将数组转化为5个空字符串数组，然后每个遍历赋值
let arr = Array(6).join(&apos; &apos;).split(&apos;&apos;).map(item =&gt; 1)
console.log(array) // [1,1,1,1,1]

// ES6
//使用Array.from可以达到初始化并填充的效果
let array = Array.from({ length: 5 }, function () { return 1 })
console.log(array) // [1,1,1,1,1]
// 上面之所以第一个参数可以传{ length: 5 }，是因为第一个参数应该传伪数组

//使用Array.fill可以快速实现初始化并填充
let array = Array(5).fill(1)
console.log(array) //[1,1,1,1,1]</code></pre><h3 id="创建新数组"><a href="#创建新数组" class="headerlink" title="创建新数组"></a>创建新数组</h3><ul>
<li>ES5</li>
</ul>
<pre><code>let array = Array(5)
let array = [&apos;&apos;, &apos;&apos;] //无法定义长度，只能每个都初始化为空字符串</code></pre><ul>
<li>ES6</li>
</ul>
<ol>
<li>Array.from</li>
</ol>
<pre><code>let array = Array.from({ length: 5 })</code></pre><ol start="2">
<li>Array.of</li>
</ol>
<pre><code>let array = Array.of(1,2,3,4,5) //参数是依此放进去的元素，可以一个参数可以多个
console.log(array) //[1,2,3,4,5]</code></pre><ol start="3">
<li>Array.prototype.fill</li>
</ol>
<pre><code>let array = Array(5).fill(1) //参数是依此放进去的元素，可以一个参数可以多个
console.log(array) //[1,1,1,1,1]</code></pre><p>Array.fill(value,start,end)<br>第一个参数：填充值<br>第二个参数：起始位置，默认为数组的开始<br>第三个函数：结束位置，默认为数组的结束<br>[start,end)</p>
<pre><code>let array = [1, 2, 3, 4, 5]
console.log(array.fill(8, 2, 4)) // [1,2,8,8,5]</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="箭头函数不适用场景"><a href="#箭头函数不适用场景" class="headerlink" title="箭头函数不适用场景"></a>箭头函数不适用场景</h4><ul>
<li>使用箭头函数内的this值为父级作用域的this值 </li>
</ul>
<pre><code>// 作为构造函数，一个方法需要绑定到对象
const Person = (name, points) =&gt; {
  this.name = name
  this.points = points
}
const Bob = new Person(&apos;Bob&apos;, 5)
// 此声明对象会报错
1、生成一个新的对象
2、把构造函数this的值指向新生成的对象
3、把这个对象绑定它的原型对象
4、返回这个新生成的对象
但是使用箭头函数this值没有绑定到新生成的对象上，导致报错
Person.prototype.updatePoints = () =&gt; {
  this.points++
  console.log(this.points)
}
// 返回NaN
// 这两个操作都需要使用function函数才能正确绑定this值</code></pre><ul>
<li>绑定事件时</li>
</ul>
<pre><code>const btn = document.querySelector(&apos;.btn&apos;)
btn.addEventListener(&apos;click&apos;, () =&gt; {
  this.classList.add(&apos;enlarge&apos;)
  setTimeout(() =&gt; {
    this.classList.remove(&apos;enlarge&apos;)
  }, 2000)
})
// 绑定事件报错，因为箭头函数内this不指向btn
// 需要使用function函数，之后内部setTimeout使用箭头函数，this指向btn</code></pre><ul>
<li>需要使用arguments对象时 </li>
</ul>
<pre><code>const sum = () =&gt; {
  return Array.from(arguments)
              .reduce((prevSum, value) =&gt; prevSum + value, 0)
}
// 调用sum方法报错，因为箭头函数中没有arguments对象，所以需要使用function函数
// 或者使用Rest参数的方法
const sum = (...args) =&gt; {
  return args.reduce((prevSum, value) =&gt; prevSum + value, 0)
}</code></pre><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><pre><code>const person = &apos;Bob&apos;
const age = 5
const sentence = `${person} is ${age + 5} years old.`
const template = `
  &lt;div&gt;
    &lt;p&gt;${person}&lt;/p&gt;
  &lt;/div&gt;
`
//大括号内的变量，可以是变量、对象属性、js表达式或函数</code></pre>]]></content>
      <categories>
        <category>ES6，作用域，数组</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>scss基础知识</title>
    <url>/posts/3285850959.html</url>
    <content><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><p>  scss变量的声明和css属性的声明很像<br>  $primary-color: #1269b5;<br>  $primary-border: 1px solid $primary-color;<br>  使用方式</p>
<pre><code>div.box {
  background-color: $primary-color;
  border: $primary-border;
}</code></pre><h3 id="2-嵌套"><a href="#2-嵌套" class="headerlink" title="2.嵌套"></a>2.嵌套</h3><p>  css的书写方式</p>
<pre><code>.nav{
  height: 100px
}
.nav ul{
  margin: 0;
}
.nav ul li{
  float: left;
  list-style: none;
}</code></pre><p>  scss的嵌套方式</p>
<pre><code>.nav{
  height: 100px
  ul{
    margin: 0;
    li{
      float: left;
      list-style: none;
    }
    a {
      display: block;
      color: #000;
      /* 伪类选择器使用 &amp; 符号，引用父选择器 */
      &amp;:hover{
        background-color: #0d2f7e;
        color: #fff;
      }
    }
  }
  &amp; &amp;-text{
    font-size: 15px;
  }
}</code></pre><p>  嵌套可以用在样式的属性里面<br>  css的写法</p>
<pre><code>.box{
  font-size: 14px;
  font-weight: normal;
  border: 1px solid #000;
  boder-left: 0;
  boder-right: 0;
}</code></pre><p>  scss的嵌套写法</p>
<pre><code>.box{
  font: {
    size：14px;
    weight: normal;
  }
  border: 1px solid #000 {
    left: 0;
    right: 0;
  }
}</code></pre><h3 id="3-mixin"><a href="#3-mixin" class="headerlink" title="3.mixin"></a>3.mixin</h3><p>  定义好的有名字的样式，可以重复使用，类似js的函数<br>  darken函数，加深指定的颜色</p>
<pre><code>@mixin 名字(参数1，参数2...){
  ...
}

@mixin alert($text-color, $background){
  color: $text-color;
  background-color: $background;
  a{
    color: darken($text-color, 10%)
  }
}

.alert-warning {
  @include alert(#8a6d3b, #fcf8e3);
}
/* 指定变量名赋值 */
.alert-info {
  @include alert($background: #d9edf7, $text-color:#31708f);
}</code></pre><h3 id="4-extend-继承-扩展"><a href="#4-extend-继承-扩展" class="headerlink" title="4.@extend 继承/扩展"></a>4.@extend 继承/扩展</h3><pre><code>.alert{
  padding: 15px;
}
.alert a{
  font-weight: bold;
}
.alert-info{
  @extend .alert;
  background-color: #d9edf7;
}</code></pre><h3 id="5-import-导入样式文件Partials"><a href="#5-import-导入样式文件Partials" class="headerlink" title="5.@import 导入样式文件Partials"></a>5.@import 导入样式文件Partials</h3><p>  Partials样式文件命名必须下划线_开头<br>  创建一个_base.scss文件</p>
<pre><code>body{
  margin: 0;
  padding: 0;
}</code></pre><p>  然后在style.scss文件中导入</p>
<pre><code>@import &quot;base&quot;;

.alert{
  padding: 15px;
}
.alert a{
  font-weight: bold;
}</code></pre><h3 id="6-Comment"><a href="#6-Comment" class="headerlink" title="6.Comment"></a>6.Comment</h3><pre><code>/*
 * 多行注释，会在编译输出的css中保留
 * 但是会在压缩输出的css中删除
 */

 // 单行注释会在编译输出中删除

 /*!
  * 强制注释，会在一直在css中保留
  * 
  */</code></pre><h3 id="7-Data-Type"><a href="#7-Data-Type" class="headerlink" title="7.Data Type"></a>7.Data Type</h3><ol>
<li>数字运算</li>
</ol>
<pre><code>2 + 8 
= 10
2 * 8
= 16
8 / 2
= 8/2
(8 / 2)
= 4
5px * 5px
= 10px
5px - 2
= 3px
5px * 2
= 10px
5px * 2px
= 10px*px
(10px / 2)
= 5px
(10px / 2px)
= 5</code></pre><ol start="2">
<li>数字函数</li>
</ol>
<pre><code>绝对值函数
abs(-10px)
= 10px
四舍五入函数
round(3.5)
= 4
round(3.2)
= 3
进位函数
ceil(3.2)
= 4
向下取整
floor(3.6)
= 3
生成百分号%函数
percentage(65 / 100)
= 65%
取最小值
min(1, 2, 3)
= 1
取最大值
max(1, 2, 3)
= 3</code></pre><ol start="3">
<li>String字符串</li>
</ol>
<pre><code>&quot;ni&quot; + hao
= &quot;nihao
ni + &quot;hao&quot;
= &quot;nihao&quot;
&quot;ni&quot; + 123
= &quot;ni123&quot;
ni - hao
= &quot;ni-hao&quot;
ni / hao
= &quot;ni/hao&quot;
ni * hao
= 报错 SyntexError</code></pre><ol start="4">
<li>字符串函数</li>
</ol>
<pre><code>$greeting: &quot;hello world&quot;
= &quot;hello world&quot;
$greeting
= &quot;hello world&quot;
to-upper-case($greeting)
= &quot;HELLO WORLD&quot;
to-lower-case($greeting)
= &quot;hello world&quot;
str-length($greeting)
= 13
str-index($greeting, &quot;hello&quot;)
= 1
str-index($greeting, &quot;world&quot;)
= 7
str-insert($greeting, &quot;.css&quot;, 13)
= &quot;hello world.css&quot;</code></pre><ol start="5">
<li>Color 颜色函数</li>
</ol>
<pre><code>rgb(红,绿,蓝)
rgb(255,0,0)

rgba(红,绿,蓝,透明度)
rgba(255,0,0,0.5)

hsl(色相,饱和度,明度)
hsl(0, 100%, 50%)

hsla(色相,饱和度,明度,透明度)
hsla(0,100%,50%,0.5)

$base-color: #ff0000
$base-color-hsl: hsl(0, 100%, 50%)
background-color: adjust-hue($base-color-hsl, 137deg)
background-color: adjust-hue($base-color, 137deg)

$base-color: hsl(222, 100%, 50%)
$light-color: lighten($base-color, 30%)
$light-color: darken($base-color, 20%)

$base-color: hsl(222, 50%, 50%)
$saturate-color: saturate($base-color, 30%)
$desaturate-color: desaturate($base-color, 20%)

$base-color: hsla(222, 50%, 50%, 0.5)
$opacify-color: opacify($base-color, 0.3)
$transparentize-color: desaturate($base-color, 0.2)</code></pre><h3 id="8-map与相关函数"><a href="#8-map与相关函数" class="headerlink" title="8.map与相关函数"></a>8.map与相关函数</h3><pre><code>$map:(key1: value1, key2: value2)

$colors:(light: #ffffff, dark: #000000)
map-get($colors, light)
map-get($colors, dark)

map-keys($colors)
= (&quot;light&quot;,&quot;dark&quot;)

map-values($colors)
= (#ffffff, #000000)</code></pre><h3 id="9-Interpolation"><a href="#9-Interpolation" class="headerlink" title="9.Interpolation"></a>9.Interpolation</h3><pre><code>$version: &quot;0.0.1&quot;;
/* 项目当前版本号： #{$version} */

$name: &quot;info&quot;;
$attr: &quot;border&quot;;
.alert-#{name} {
  #{$attr}-color: #ccc;
}</code></pre><h3 id="11-控制指令"><a href="#11-控制指令" class="headerlink" title="11.控制指令"></a>11.控制指令</h3><pre><code>+ @if 条件 {...}

  $use-prefixes: true;
  $theme: &quot;dark&quot;;
  .rounded{
    @if $use-prefixes {
      -webkit-border-radius: 5px;
      -moz-border-radius: 5px;
      -ms-border-radius: 5px;
      -o-border-radius: 5px;
    }
    border-radius: 5px;
  }

  body{
    @if $theme == dark{
      background-color: black;
    }@else if $theme == light{
      background-color: white;
    }@else {
      background-color: grey;
    }
  }


+ @for $var from &lt;开始值&gt; through/to &lt;结束值&gt; {...}

  $columns: 4;
  @for $i from 1 through $columns {
    .col-#{$i} {
      width: 100% / $columns * $i;
    }
  }
  @for $i from 1 to $columns {
    .col-#{$i} {
      width: 100% / $columns * $i;
    }
  }

+ @each $var in $list {...}

  $icons: success error warning;
  @each $icon in $icons {
    .icon-#{$icon} {
      background-image: url(.../images/icons/#{$icon}.png)
    }
  }

+ @while 条件 {...}

  $i: 6;
  @while $i&gt;0 {
    .item-#{$i} {
      width: 5px * $i;
    }
    $i: $i - 2;
  }</code></pre><h3 id="11-自定义函数"><a href="#11-自定义函数" class="headerlink" title="11.自定义函数"></a>11.自定义函数</h3><pre><code>$colors: (light: #ffffff, dark: #000000);
@function color($key){
  @return map-get($colors, $key);
}

body{
  backgound-color: color(light);
}</code></pre><h3 id="12-警告与错误"><a href="#12-警告与错误" class="headerlink" title="12.警告与错误"></a>12.警告与错误</h3><pre><code>$colors: (light: #ffffff, dark: #000000);
@function color($key){
  @if not map-has-key($colors, $key) {
    @warn &quot;在$colors中没有找到 #{$key}这个key&quot;
  }
  @return map-get($colors, $key);
}

body{
  backgound-color: color(light);
}</code></pre><h3 id="13-部分错误"><a href="#13-部分错误" class="headerlink" title="13.部分错误"></a>13.部分错误</h3><ul>
<li>vue安装node-scss报错<br>在搭建vue脚手架 或者是在vue项目中，想使用sass的功能</li>
</ul>
<pre><code>npm install node-sass sass-loader style-loader --D
报错Modele build failed: TypeError: this.getResolve is not a function at Object.loader...</code></pre><p>  这是因为当前sass的版本太高，webpack编译时出现了错误，这个时候只需要换成低版本的就行，先卸载当前版本，然后安装指定的版本。</p>
<pre><code>卸载当前版本   npm uninstall sass-loader
安装     npm install sass-loader@7.3.1 --save-dev</code></pre><h3 id="14-默认css"><a href="#14-默认css" class="headerlink" title="14.默认css"></a>14.默认css</h3><pre><code>/* ==================
        初始化
==================== */
* {
margin: 0;
padding: 0;
}

body {
  background-color: #FFF;
  font-size: 14px;
  color: #000;
  font-family: Helvetica Neue, Helvetica, sans-serif;
}

img {
  box-sizing: border-box;
}

.round {
  border-radius: 5000px;
}

.circle{
  border-radius: 50%;
}
.radius {
  border-radius: 3px;
}

.radius8 {
  border-radius: 13px;
}

/* ==================
          图片
==================== */

img {
  max-width: 100%;
  display: inline-block;
  position: relative;
  z-index: 0;
}

img.loading::before {
  content: &quot;&quot;;
  background-color: #f5f5f5;
  display: block;
  position: absolute;
  width: 100%;
  height: 100%;
  z-index: -2;
}

img.loading::after {
  content: &quot;\e7f1&quot;;
  font-family: &quot;cuIcon&quot;;
  position: absolute;
  top: 0;
  left: 0;
  width: 16px;
  height: 16px;
  line-height: 16px;
  right: 0;
  bottom: 0;
  z-index: -1;
  font-size: 16px;
  margin: auto;
  color: #ccc;
  -webkit-animation: cuIcon-spin 2s infinite linear;
  animation: cuIcon-spin 2s infinite linear;
  display: block;
}

.response {
  width: 100%;
}


/* ==================
          边框
==================== */

/* -- 实线 -- */

.solid,
.solid-top,
.solid-right,
.solid-bottom,
.solid-left,
.solids,
.solids-top,
.solids-right,
.solids-bottom,
.solids-left,
.dashed,
.dashed-top,
.dashed-right,
.dashed-bottom,
.dashed-left {
  position: relative;
}

.solid::after,
.solid-top::after,
.solid-right::after,
.solid-bottom::after,
.solid-left::after,
.solids::after,
.solids-top::after,
.solids-right::after,
.solids-bottom::after,
.solids-left::after,
.dashed::after,
.dashed-top::after,
.dashed-right::after,
.dashed-bottom::after,
.dashed-left::after {
  content: &quot; &quot;;
  width: 200%;
  height: 200%;
  position: absolute;
  top: 0;
  left: 0;
  border-radius: inherit;
  transform: scale(0.5);
  transform-origin: 0 0;
  pointer-events: none;
  box-sizing: border-box;
}

.solid::after {
  border: 1px solid rgba(0, 0, 0, 0.5);
}

.solid-top::after {
  border-top: 1px solid rgba(0, 0, 0, 0.5);
}

.solid-right::after {
  border-right: 1px solid rgba(0, 0, 0, 0.5);
}

.solid-bottom::after {
  border-bottom: 1px solid rgba(0, 0, 0, 0.5);
}

.solid-left::after {
  border-left: 1px solid rgba(0, 0, 0, 0.5);
}

.solids::after {
  border: 4px solid #eee;
}

.solids-top::after {
  border-top: 4px solid #eee;
}

.solids-right::after {
  border-right: 4px solid #eee;
}

.solids-bottom::after {
  border-bottom: 4px solid #eee;
}

.solids-left::after {
  border-left: 4px solid #eee;
}

/* -- 虚线 -- */

.dashed::after {
  border: 1px dashed #ddd;
}

.dashed-top::after {
  border-top: 1px dashed #ddd;
}

.dashed-right::after {
  border-right: 1px dashed #ddd;
}

.dashed-bottom::after {
  border-bottom: 1px dashed #ddd;
}

.dashed-left::after {
  border-left: 1px dashed #ddd;
}

/* -- 阴影 -- */

.shadow[class*=&apos;white&apos;] {
  --ShadowSize: 0 1px 3px;
}

.shadow-lg {
  --ShadowSize: 0px 20px 50px 0px;
}

.shadow-warp {
  position: relative;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
}

.shadow-warp:before,
.shadow-warp:after {
  position: absolute;
  content: &quot;&quot;;
  top: 10px;
  bottom: 15px;
  left: 10px;
  width: 50%;
  box-shadow: 0 15px 10px rgba(0, 0, 0, 0.2);
  transform: rotate(-3deg);
  z-index: -1;
}

.shadow-warp:after {
  right: 10px;
  left: auto;
  transform: rotate(3deg);
}

.shadow-blur {
  position: relative;
}

.shadow-blur::before {
  content: &quot;&quot;;
  display: block;
  background: inherit;
  filter: blur(5px);
  position: absolute;
  width: 100%;
  height: 100%;
  top: 5px;
  left: 5px;
  z-index: -1;
  opacity: 0.4;
  transform-origin: 0 0;
  border-radius: inherit;
  transform: scale(1, 1);
}

/* ==================
          按钮
==================== */

.cu-btn {
  position: relative;
  border: 0px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  padding: 0 15px;
  font-size: 14px;
  height: 62px;
  line-height: 1;
  text-align: center;
  text-decoration: none;
  overflow: visible;
  margin-left: initial;
  transform: translate(0px, 0px);
  margin-right: initial;
}

.cu-btn::after {
  display: none;
}

.cu-btn:not([class*=&quot;bg-&quot;]) {
  background-color: #f0f0f0;
}

.cu-btn[class*=&quot;line&quot;] {
  background-color: transparent;
}

.cu-btn[class*=&quot;line&quot;]::after {
  content: &quot; &quot;;
  display: block;
  width: 200%;
  height: 200%;
  position: absolute;
  top: 0;
  left: 0;
  border: 1px solid currentColor;
  transform: scale(0.5);
  transform-origin: 0 0;
  box-sizing: border-box;
  border-radius: 11px;
  z-index: 1;
  pointer-events: none;
}

.cu-btn.round[class*=&quot;line&quot;]::after {
  border-radius: 1000px;
}

.cu-btn[class*=&quot;lines&quot;]::after {
  border: 3px solid currentColor;
}

.cu-btn[class*=&quot;bg-&quot;]::after {
  display: none;
}

.cu-btn.sm {
  padding: 0 10px;
  font-size: 10px;
  height: 44px;
}

.cu-btn.lg {
  padding: 0 20px;
  font-size: 16px;
  height: 40px;
}

.cu-btn.cuIcon.sm {
  width: 44px;
  height: 44px;
}

.cu-btn.cuIcon {
  width: 62px;
  height: 62px;
  border-radius: 500px;
  padding: 0;
}

.cu-btn.shadow-blur::before {
  top: 2px;
  left: 2px;
  filter: blur(3px);
  opacity: 0.6;
}

.cu-btn.button-hover {
  transform: translate(1px, 1px);
}

.block {
  display: block;
}

.cu-btn.block {
  display: flex;
}

.cu-btn[disabled] {
  opacity: 0.6;
  color: #ffffff;
}

/* ==================
          徽章
==================== */

.cu-tag {
  font-size: 12px;
  vertical-align: middle;
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  padding: 0px 13px;
  height: 44px;
  font-family: Helvetica Neue, Helvetica, sans-serif;
  white-space: nowrap;
}

.cu-tag:not([class*=&quot;bg&quot;]):not([class*=&quot;line&quot;]) {
  background-color: #f1f1f1;
}

.cu-tag[class*=&quot;line-&quot;]::after {
  content: &quot; &quot;;
  width: 200%;
  height: 200%;
  position: absolute;
  top: 0;
  left: 0;
  border: 1px solid currentColor;
  transform: scale(0.5);
  transform-origin: 0 0;
  box-sizing: border-box;
  border-radius: inherit;
  z-index: 1;
  pointer-events: none;
}

.cu-tag.radius[class*=&quot;line&quot;]::after {
  border-radius: 11px;
}

.cu-tag.round[class*=&quot;line&quot;]::after {
  border-radius: 1000px;
}

.cu-tag[class*=&quot;line-&quot;]::after {
  border-radius: 0;
}

.cu-tag+.cu-tag {
  margin-left: 5px;
}

.cu-tag.sm {
  font-size: 10px;
  padding: 0px 11px;
  height: 16px;
}

.cu-capsule {
  display: inline-flex;
  vertical-align: middle;
}

.cu-capsule+.cu-capsule {
  margin-left: 5px;
}

.cu-capsule .cu-tag {
  margin: 0;
}

.cu-capsule .cu-tag[class*=&quot;line-&quot;]:last-child::after {
  border-left: 0px solid transparent;
}

.cu-capsule .cu-tag[class*=&quot;line-&quot;]:first-child::after {
  border-right: 0px solid transparent;
}

.cu-capsule.radius .cu-tag:first-child {
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.cu-capsule.radius .cu-tag:last-child::after,
.cu-capsule.radius .cu-tag[class*=&quot;line-&quot;] {
  border-top-right-radius: 11px;
  border-bottom-right-radius: 11px;
}

.cu-capsule.round .cu-tag:first-child {
  border-top-left-radius: 200px;
  border-bottom-left-radius: 200px;
  text-indent: 2px;
}

.cu-capsule.round .cu-tag:last-child::after,
.cu-capsule.round .cu-tag:last-child {
  border-top-right-radius: 200px;
  border-bottom-right-radius: 200px;
  text-indent: -2px;
}

.cu-tag.badge {
  border-radius: 200px;
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 10px;
  padding: 0px 5px;
  height: 14px;
  color: #ffffff;
}

.cu-tag.badge:not([class*=&quot;bg-&quot;]) {
  background-color: #dd514c;
}

.cu-tag:empty:not([class*=&quot;cuIcon-&quot;]) {
  padding: 0px;
  width: 13px;
  height: 13px;
  top: -2px;
  right: -2px;
}

.cu-tag[class*=&quot;cuIcon-&quot;] {
  width: 16px;
  height: 16px;
  top: -2px;
  right: -2px;
}

/* ==================
          头像
==================== */

.cu-avatar {
  font-variant: small-caps;
  margin: 0;
  padding: 0;
  display: inline-flex;
  text-align: center;
  justify-content: center;
  align-items: center;
  background-color: #ccc;
  color: #ffffff;
  white-space: nowrap;
  position: relative;
  width: 62px;
  height: 62px;
  background-size: cover;
  background-position: center;
  vertical-align: middle;
  font-size: 1.5em;
}

.cu-avatar.sm {
  width: 44px;
  height: 44px;
  font-size: 1em;
}

.cu-avatar.lg {
  width: 93px;
  height: 93px;
  font-size: 2em;
}

.cu-avatar.xl {
  width: 114px;
  height: 114px;
  font-size: 2.5em;
}

.cu-avatar .avatar-text {
  font-size: 0.4em;
}

.cu-avatar-group {
  direction: rtl;
  unicode-bidi: bidi-override;
  padding: 0 5px 0 20px;
  display: inline-block;
}

.cu-avatar-group .cu-avatar {
  margin-left: -15px;
  border: 2px solid #f1f1f1;
  vertical-align: middle;
}

.cu-avatar-group .cu-avatar.sm {
  margin-left: -10px;
  border: 1px solid #f1f1f1;
}

/* ==================
        进度条
==================== */

.cu-progress {
  overflow: hidden;
  height: 14px;
  background-color: #ebeef5;
  display: inline-flex;
  align-items: center;
  width: 100%;
}

.cu-progress+view,
.cu-progress+text {
  line-height: 1;
}

.cu-progress.xs {
  height: 5px;
}

.cu-progress.sm {
  height: 10px;
}

.cu-progress view {
  width: 0;
  height: 100%;
  align-items: center;
  display: flex;
  justify-items: flex-end;
  justify-content: space-around;
  font-size: 10px;
  color: #ffffff;
  transition: width 0.6s ease;
}

.cu-progress text {
  align-items: center;
  display: flex;
  font-size: 10px;
  color: #333333;
  text-indent: 5px;
}

.cu-progress.text-progress {
  padding-right: 30px;
}

.cu-progress.striped view {
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
  background-size: 71px 71px;
}

.cu-progress.active view {
  animation: progress-stripes 2s linear infinite;
}

@keyframes progress-stripes {
  from {
    background-position: 71px 0;
  }

  to {
    background-position: 0 0;
  }
}

/* ==================
          加载
==================== */

.cu-load {
  display: block;
  line-height: 3em;
  text-align: center;
}

.cu-load::before {
  font-family: &quot;cuIcon&quot;;
  display: inline-block;
  margin-right: 3px;
}

.cu-load.loading::before {
  content: &quot;\e67a&quot;;
  animation: cuIcon-spin 2s infinite linear;
}

.cu-load.loading::after {
  content: &quot;加载中...&quot;;
}

.cu-load.over::before {
  content: &quot;\e64a&quot;;
}

.cu-load.over::after {
  content: &quot;没有更多了&quot;;
}

.cu-load.erro::before {
  content: &quot;\e658&quot;;
}

.cu-load.erro::after {
  content: &quot;加载失败&quot;;
}

.cu-load.load-cuIcon::before {
  font-size: 16px;
}

.cu-load.load-cuIcon::after {
  display: none;
}

.cu-load.load-cuIcon.over {
  display: none;
}

.cu-load.load-modal {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 120px;
  left: 0;
  margin: auto;
  width: 230px;
  height: 230px;
  background-color: #ffffff;
  border-radius: 5px;
  box-shadow: 0 0 0px 2000px rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: center;
  font-size: 14px;
  z-index: 9999;
  line-height: 2.4em;
}

.cu-load.load-modal [class*=&quot;cuIcon-&quot;] {
  font-size: 30px;
}

.cu-load.load-modal image {
  width: 70px;
  height: 70px;
}

.cu-load.load-modal::after {
  content: &quot;&quot;;
  position: absolute;
  background-color: #ffffff;
  border-radius: 50%;
  width: 200px;
  height: 200px;
  font-size: 10px;
  border-top: 3px solid rgba(0, 0, 0, 0.05);
  border-right: 3px solid rgba(0, 0, 0, 0.05);
  border-bottom: 3px solid rgba(0, 0, 0, 0.05);
  border-left: 3px solid #f37b1d;
  animation: cuIcon-spin 1s infinite linear;
  z-index: -1;
}

.load-progress {
  pointer-events: none;
  top: 0;
  position: fixed;
  width: 100%;
  left: 0;
  z-index: 2000;
}

.load-progress.hide {
  display: none;
}

.load-progress .load-progress-bar {
  position: relative;
  width: 100%;
  height: 2px;
  overflow: hidden;
  transition: all 200ms ease 0s;
}

.load-progress .load-progress-spinner {
  position: absolute;
  top: 5px;
  right: 5px;
  z-index: 2000;
  display: block;
}

.load-progress .load-progress-spinner::after {
  content: &quot;&quot;;
  display: block;
  width: 12px;
  height: 12px;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  border: solid 2px transparent;
  border-top-color: inherit;
  border-left-color: inherit;
  border-radius: 50%;
  -webkit-animation: load-progress-spinner 0.4s linear infinite;
  animation: load-progress-spinner 0.4s linear infinite;
}

@-webkit-keyframes load-progress-spinner {
  0% {
    -webkit-transform: rotate(0);
    transform: rotate(0);
  }

  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes load-progress-spinner {
  0% {
    -webkit-transform: rotate(0);
    transform: rotate(0);
  }

  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

/* ==================
          列表
==================== */
.grayscale {
  filter: grayscale(1);
}

.cu-list+.cu-list {
  margin-top: 15px
}

.cu-list&gt;.cu-item {
  transition: all .6s ease-in-out 0s;
  transform: translateX(0px)
}

.cu-list&gt;.cu-item.move-cur {
  transform: translateX(-230px)
}

.cu-list&gt;.cu-item .move {
  position: absolute;
  right: 0;
  display: flex;
  width: 230px;
  height: 100%;
  transform: translateX(100%)
}

.cu-list&gt;.cu-item .move view {
  display: flex;
  flex: 1;
  justify-content: center;
  align-items: center
}

.cu-list.menu-avatar {
  overflow: hidden;
}

.cu-list.menu-avatar&gt;.cu-item {
  position: relative;
  display: flex;
  padding-right: 5px;
  height: 120px;
  background-color: #ffffff;
  justify-content: flex-end;
  align-items: center
}

.cu-list.menu-avatar&gt;.cu-item&gt;.cu-avatar {
  position: absolute;
  left: 15px
}

.cu-list.menu-avatar&gt;.cu-item .flex .text-cut {
  max-width: 55px
}

.cu-list.menu-avatar&gt;.cu-item .content {
  position: absolute;
  left: 143px;
  width: calc(100% - 93px - 30px - 110px - 10px);
  line-height: 1.6em;
}

.cu-list.menu-avatar&gt;.cu-item .content.flex-sub {
  width: calc(100% - 93px - 30px - 10px);
}

.cu-list.menu-avatar&gt;.cu-item .content&gt;view:first-child {
  font-size: 15px;
  display: flex;
  align-items: center
}

.cu-list.menu-avatar&gt;.cu-item .content .cu-tag.sm {
  display: inline-block;
  margin-left: 5px;
  height: 14px;
  font-size: 13px;
  line-height: 16px
}

.cu-list.menu-avatar&gt;.cu-item .action {
  width: 50px;
  text-align: center
}

.cu-list.menu-avatar&gt;.cu-item .action view+view {
  margin-top: 5px
}

.cu-list.menu-avatar.comment&gt;.cu-item .content {
  position: relative;
  left: 0;
  width: auto;
  flex: 1;
}

.cu-list.menu-avatar.comment&gt;.cu-item {
  padding: 15px 15px 15px 110px;
  height: auto
}

.cu-list.menu-avatar.comment .cu-avatar {
  align-self: flex-start
}

.cu-list.menu&gt;.cu-item {
  position: relative;
  display: flex;
  padding: 0 15px;
  min-height: 50px;
  background-color: #ffffff;
  justify-content: space-between;
  align-items: center
}

.cu-list.menu&gt;.cu-item:last-child:after {
  border: none
}

.cu-list.menu-avatar&gt;.cu-item:after,
.cu-list.menu&gt;.cu-item:after {
  position: absolute;
  top: 0;
  left: 0;
  box-sizing: border-box;
  width: 200%;
  height: 200%;
  border-bottom: 1px solid #ddd;
  border-radius: inherit;
  content: &quot; &quot;;
  transform: scale(.5);
  transform-origin: 0 0;
  pointer-events: none
}

.cu-list.menu&gt;.cu-item.grayscale {
  background-color: #f5f5f5
}

.cu-list.menu&gt;.cu-item.cur {
  background-color: #fcf7e9
}

.cu-list.menu&gt;.cu-item.arrow {
  padding-right: 90px
}

.cu-list.menu&gt;.cu-item.arrow:before {
  position: absolute;
  top: 0;
  right: 15px;
  bottom: 0;
  display: block;
  margin: auto;
  width: 15px;
  height: 15px;
  color: #8799a3;
  content: &quot;\e6a3&quot;;
  text-align: center;
  font-size: 32px;
  font-family: cuIcon;
  line-height: 15px
}

.cu-list.menu&gt;.cu-item button.content {
  padding: 0;
  background-color: transparent;
  justify-content: flex-start
}

.cu-list.menu&gt;.cu-item button.content:after {
  display: none
}

.cu-list.menu&gt;.cu-item .cu-avatar-group .cu-avatar {
  border-color: #ffffff
}

.cu-list.menu&gt;.cu-item .content&gt;view:first-child {
  display: flex;
  align-items: center
}

.cu-list.menu&gt;.cu-item .content&gt;text[class*=cuIcon] {
  display: inline-block;
  margin-right: 5px;
  width: 1.6em;
  text-align: center
}

.cu-list.menu&gt;.cu-item .content&gt;image {
  display: inline-block;
  margin-right: 5px;
  width: 1.6em;
  height: 1.6em;
  vertical-align: middle
}

.cu-list.menu&gt;.cu-item .content {
  font-size: 15px;
  line-height: 1.6em;
  flex: 1
}

.cu-list.menu&gt;.cu-item .content .cu-tag.sm {
  display: inline-block;
  margin-left: 5px;
  height: 14px;
  font-size: 13px;
  line-height: 16px
}

.cu-list.menu&gt;.cu-item .action .cu-tag:empty {
  right: 5px
}

.cu-list.menu {
  display: block;
  overflow: hidden
}

.cu-list.menu.sm-border&gt;.cu-item:after {
  left: 15px;
  width: calc(200% - 110px)
}

.cu-list.grid&gt;.cu-item {
  position: relative;
  display: flex;
  padding: 10px 0 15px;
  transition-duration: 0s;
  flex-direction: column
}

.cu-list.grid&gt;.cu-item:after {
  position: absolute;
  top: 0;
  left: 0;
  box-sizing: border-box;
  width: 200%;
  height: 200%;
  border-right: 1px solid rgba(0, 0, 0, .1);
  border-bottom: 1px solid rgba(0, 0, 0, .1);
  border-radius: inherit;
  content: &quot; &quot;;
  transform: scale(.5);
  transform-origin: 0 0;
  pointer-events: none
}

.cu-list.grid&gt;.cu-item text {
  display: block;
  margin-top: 5px;
  color: #888;
  font-size: 23px;
  line-height: 20px
}

.cu-list.grid&gt;.cu-item [class*=cuIcon] {
  position: relative;
  display: block;
  margin-top: 10px;
  width: 100%;
  font-size: 44px
}

.cu-list.grid&gt;.cu-item .cu-tag {
  right: auto;
  left: 50%;
  margin-left: 10px
}

.cu-list.grid {
  background-color: #ffffff;
  text-align: center
}

.cu-list.grid.no-border&gt;.cu-item {
  padding-top: 5px;
  padding-bottom: 10px
}

.cu-list.grid.no-border&gt;.cu-item:after {
  border: none
}
.cu-list.no-border&gt;.cu-item:after {
  border: none
}

.cu-list.grid.no-border {
  padding: 10px 5px
}

.cu-list.grid.col-3&gt;.cu-item:nth-child(3n):after,
.cu-list.grid.col-4&gt;.cu-item:nth-child(4n):after,
.cu-list.grid.col-5&gt;.cu-item:nth-child(5n):after {
  border-right-width: 0
}

.cu-list.card-menu {
  overflow: hidden;
  margin-right: 15px;
  margin-left: 15px;
  border-radius: 10px
}


/* ==================
          操作条
==================== */

.cu-bar {
  display: flex;
  position: relative;
  align-items: center;
  min-height: 50px;
  justify-content: space-between;
}

.cu-bar .action {
  display: flex;
  align-items: center;
  height: 100%;
  justify-content: center;
  max-width: 100%;
}

.cu-bar .action.border-title {
  position: relative;
  top: -5px;
}

.cu-bar .action.border-title text[class*=&quot;bg-&quot;]:last-child {
  position: absolute;
  bottom: -0.5rem;
  min-width: 2rem;
  height: 3px;
  left: 0;
}

.cu-bar .action.sub-title {
  position: relative;
  top: -0.2rem;
}

.cu-bar .action.sub-title text {
  position: relative;
  z-index: 1;
}

.cu-bar .action.sub-title text[class*=&quot;bg-&quot;]:last-child {
  position: absolute;
  display: inline-block;
  bottom: -0.2rem;
  border-radius: 3px;
  width: 100%;
  height: 0.6rem;
  left: 0.6rem;
  opacity: 0.3;
  z-index: 0;
}

.cu-bar .action.sub-title text[class*=&quot;text-&quot;]:last-child {
  position: absolute;
  display: inline-block;
  bottom: -0.7rem;
  left: 0.5rem;
  opacity: 0.2;
  z-index: 0;
  text-align: right;
  font-weight: 900;
  font-size: 18px;
}

.cu-bar.justify-center .action.border-title text:last-child,
.cu-bar.justify-center .action.sub-title text:last-child {
  left: 0;
  right: 0;
  margin: auto;
  text-align: center;
}

.cu-bar .action:first-child {
  margin-left: 15px;
  font-size: 15px;
}

.cu-bar .action text.text-cut {
  text-align: left;
  width: 100%;
}

.cu-bar .cu-avatar:first-child {
  margin-left: 10px;
}

.cu-bar .action:first-child&gt;text[class*=&quot;cuIcon-&quot;] {
  margin-left: -0.3em;
  margin-right: 0.3em;
}

.cu-bar .action:last-child {
  margin-right: 15px;
}

.cu-bar .action&gt;text[class*=&quot;cuIcon-&quot;],
.cu-bar .action&gt;view[class*=&quot;cuIcon-&quot;] {
  font-size: 18px;
}

.cu-bar .action&gt;text[class*=&quot;cuIcon-&quot;]+text[class*=&quot;cuIcon-&quot;] {
  margin-left: 0.5em;
}

.cu-bar .content {
  position: absolute;
  text-align: center;
  width: calc(100% - 320px);
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
  margin: auto;
  height: 30px;
  font-size: 16px;
  line-height: 30px;
  cursor: none;
  /* 取消点击事件 */
  /* pointer-events: none; */
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}

.cu-bar.ios .content {
  bottom: 7px;
  height: 30px;
  font-size: 16px;
  line-height: 30px;
}

.cu-bar.btn-group {
  justify-content: space-around;
}

.cu-bar.btn-group button {
  padding: 10px 16px;
}

.cu-bar.btn-group button {
  flex: 1;
  margin: 0 10px;
  max-width: 50%;
}

.cu-bar .search-form {
  background-color: #f5f5f5;
  line-height: 62px;
  height: 62px;
  font-size: 12px;
  color: #333333;
  flex: 1;
  display: flex;
  align-items: center;
  margin: 0 15px;
}

.cu-bar .search-form+.action {
  margin-right: 15px;
}

.cu-bar .search-form input {
  flex: 1;
  padding-right: 15px;
  height: 62px;
  line-height: 62px;
  font-size: 23px;
  background-color: transparent;
}

.cu-bar .search-form [class*=&quot;cuIcon-&quot;] {
  margin: 0 0.5em 0 0.8em;
}

.cu-bar .search-form [class*=&quot;cuIcon-&quot;]::before {
  top: 0px;
}

.cu-bar.fixed,
.nav.fixed {
  position: fixed;
  width: 100%;
  top: 0;
  z-index: 1024;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.cu-bar.foot {
  position: fixed;
  width: 100%;
  bottom: 0;
  z-index: 1024;
  box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.1);
}

.cu-bar.tabbar {
  padding: 0;
  height: calc(50px + env(safe-area-inset-bottom) / 2);
  padding-bottom: calc(env(safe-area-inset-bottom) / 2);
}

.cu-tabbar-height {
  min-height: 50px;
  height: calc(50px + env(safe-area-inset-bottom) / 2);
}

.cu-bar.tabbar.shadow {
  box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.1);
}

.cu-bar.tabbar .action {
  font-size: 21px;
  position: relative;
  flex: 1;
  text-align: center;
  padding: 0;
  display: block;
  height: auto;
  line-height: 1;
  margin: 0;
  background-color: inherit;
  overflow: initial;
}

.cu-bar.tabbar.shop .action {
  width: 120px;
  flex: initial;
}

.cu-bar.tabbar .action.add-action {
  position: relative;
  z-index: 2;
  padding-top: 25px;
}

.cu-bar.tabbar .action.add-action [class*=&quot;cuIcon-&quot;] {
  position: absolute;
  width: 70px;
  z-index: 2;
  height: 70px;
  border-radius: 50%;
  line-height: 70px;
  font-size: 25px;
  top: -35upx;
  left: 0;
  right: 0;
  margin: auto;
  padding: 0;
}

.cu-bar.tabbar .action.add-action::after {
  content: &quot;&quot;;
  position: absolute;
  width: 50px;
  height: 50px;
  top: -25px;
  left: 0;
  right: 0;
  margin: auto;
  box-shadow: 0 -3upx 4px rgba(0, 0, 0, 0.08);
  border-radius: 25px;
  background-color: inherit;
  z-index: 0;
}

.cu-bar.tabbar .action.add-action::before {
  content: &quot;&quot;;
  position: absolute;
  width: 50px;
  height: 15px;
  bottom: 15px;
  left: 0;
  right: 0;
  margin: auto;
  background-color: inherit;
  z-index: 1;
}

.cu-bar.tabbar .btn-group {
  flex: 1;
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 5px;
}

.cu-bar.tabbar button.action::after {
  border: 0;
}

.cu-bar.tabbar .action [class*=&quot;cuIcon-&quot;] {
  width: 50px;
  position: relative;
  display: block;
  height: auto;
  margin: 0 auto 5px;
  text-align: center;
  font-size: 20px;
}

.cu-bar.tabbar .action .cuIcon-cu-image {
  margin: 0 auto;
}

.cu-bar.tabbar .action .cuIcon-cu-image image {
  width: 25px;
  height: 25px;
  display: inline-block;
}

.cu-bar.tabbar .submit {
  align-items: center;
  display: flex;
  justify-content: center;
  text-align: center;
  position: relative;
  flex: 2;
  align-self: stretch;
}

.cu-bar.tabbar .submit:last-child {
  flex: 2.6;
}

.cu-bar.tabbar .submit+.submit {
  flex: 2;
}

.cu-bar.tabbar.border .action::before {
  content: &quot; &quot;;
  width: 200%;
  height: 200%;
  position: absolute;
  top: 0;
  left: 0;
  transform: scale(0.5);
  transform-origin: 0 0;
  border-right: 1px solid rgba(0, 0, 0, 0.1);
  z-index: 3;
}

.cu-bar.tabbar.border .action:last-child:before {
  display: none;
}

.cu-bar.input {
  padding-right: 10px;
  background-color: #ffffff;
}

.cu-bar.input input {
  overflow: initial;
  line-height: 62px;
  height: 62px;
  min-height: 62px;
  flex: 1;
  font-size: 15px;
  margin: 0 10px;
}

.cu-bar.input .action {
  margin-left: 10px;
}

.cu-bar.input .action [class*=&quot;cuIcon-&quot;] {
  font-size: 44px;
}

.cu-bar.input input+.action {
  margin-right: 10px;
  margin-left: 0px;
}

.cu-bar.input .action:first-child [class*=&quot;cuIcon-&quot;] {
  margin-left: 0px;
}

.cu-custom {
  display: block;
  position: relative;
}

.cu-custom .cu-bar .content {
  width: calc(100% - 400px);
}

.cu-custom .cu-bar .content image {
  height: 30px;
  width: 220px;
}

.cu-custom .cu-bar {
  min-height: 0px;
  box-shadow: 0px 0px 0px;
  z-index: 9999;
}

.cu-custom .cu-bar .border-custom {
  position: relative;
  background: rgba(0, 0, 0, 0.15);
  border-radius: 1000px;
  height: 30px;
}

.cu-custom .cu-bar .border-custom::after {
  content: &quot; &quot;;
  width: 200%;
  height: 200%;
  position: absolute;
  top: 0;
  left: 0;
  border-radius: inherit;
  transform: scale(0.5);
  transform-origin: 0 0;
  pointer-events: none;
  box-sizing: border-box;
  border: 1px solid #ffffff;
  opacity: 0.5;
}

.cu-custom .cu-bar .border-custom::before {
  content: &quot; &quot;;
  width: 1px;
  height: 110%;
  position: absolute;
  top: 22.5%;
  left: 0;
  right: 0;
  margin: auto;
  transform: scale(0.5);
  transform-origin: 0 0;
  pointer-events: none;
  box-sizing: border-box;
  opacity: 0.6;
  background-color: #ffffff;
}

.cu-custom .cu-bar .border-custom text {
  display: block;
  flex: 1;
  margin: auto !important;
  text-align: center;
  font-size: 32px;
}

/* ==================
        导航栏
==================== */

.nav {
  white-space: nowrap;
}

::-webkit-scrollbar {
  display: none;
}

.nav .cu-item {
  height: 90px;
  display: inline-block;
  line-height: 90px;
  margin: 0 5px;
  padding: 0 10px;
}

.nav .cu-item.cur {
  border-bottom: 2px solid;
}

/* ==================
        时间轴
==================== */

.cu-timeline {
  display: block;
  background-color: #ffffff;
}

.cu-timeline .cu-time {
  width: 110px;
  text-align: center;
  padding: 10px 0;
  font-size: 23px;
  color: #888;
  display: block;
}

.cu-timeline&gt;.cu-item {
  padding: 15px 15px 15px 110px;
  position: relative;
  display: block;
  z-index: 0;
}

.cu-timeline&gt;.cu-item:not([class*=&quot;text-&quot;]) {
  color: #ccc;
}

.cu-timeline&gt;.cu-item::after {
  content: &quot;&quot;;
  display: block;
  position: absolute;
  width: 1px;
  background-color: #ddd;
  left: 30px;
  height: 100%;
  top: 0;
  z-index: 8;
}

.cu-timeline&gt;.cu-item::before {
  font-family: &quot;cuIcon&quot;;
  display: block;
  position: absolute;
  top: 18px;
  z-index: 9;
  background-color: #ffffff;
  width: 25px;
  height: 25px;
  text-align: center;
  border: none;
  line-height: 25px;
  left: 18px;
}

.cu-timeline&gt;.cu-item:not([class*=&quot;cuIcon-&quot;])::before {
  content: &quot;\e763&quot;;
}

.cu-timeline&gt;.cu-item[class*=&quot;cuIcon-&quot;]::before {
  background-color: #ffffff;
  width: 25px;
  height: 25px;
  text-align: center;
  border: none;
  line-height: 25px;
  left: 18px;
}

.cu-timeline&gt;.cu-item&gt;.content {
  padding: 15px;
  border-radius: 3px;
  display: block;
  line-height: 1.6;
}

.cu-timeline&gt;.cu-item&gt;.content:not([class*=&quot;bg-&quot;]) {
  background-color: #f1f1f1;
  color: #333333;
}

.cu-timeline&gt;.cu-item&gt;.content+.content {
  margin-top: 10px;
}

/* ==================
        聊天
==================== */

.cu-chat {
  display: flex;
  flex-direction: column;
}

.cu-chat .cu-item {
  display: flex;
  padding: 15px 15px 70px;
  position: relative;
}

.cu-chat .cu-item&gt;.cu-avatar {
  width: 40px;
  height: 40px;
}

.cu-chat .cu-item&gt;.main {
  max-width: calc(100% - 230px);
  margin: 0 20px;
  display: flex;
  align-items: center;
}

.cu-chat .cu-item&gt;image {
  height: 310px;
}

.cu-chat .cu-item&gt;.main .content {
  padding: 10px;
  border-radius: 3px;
  display: inline-flex;
  max-width: 100%;
  align-items: center;
  font-size: 15px;
  position: relative;
  min-height: 40px;
  line-height: 20px;
  text-align: left;
}

.cu-chat .cu-item&gt;.main .content:not([class*=&quot;bg-&quot;]) {
  background-color: #ffffff;
  color: #333333;
}

.cu-chat .cu-item .date {
  position: absolute;
  font-size: 12px;
  color: #8799a3;
  width: calc(100% - 310px);
  bottom: 10px;
  left: 130px;
}

.cu-chat .cu-item .action {
  padding: 0 15px;
  display: flex;
  align-items: center;
}

.cu-chat .cu-item&gt;.main .content::after {
  content: &quot;&quot;;
  top: 27upx;
  transform: rotate(45deg);
  position: absolute;
  z-index: 100;
  display: inline-block;
  overflow: hidden;
  width: 12px;
  height: 12px;
  left: -11px;
  right: initial;
  background-color: inherit;
}

.cu-chat .cu-item.self&gt;.main .content::after {
  left: auto;
  right: -11px;
}

.cu-chat .cu-item&gt;.main .content::before {
  content: &quot;&quot;;
  top: 15px;
  transform: rotate(45deg);
  position: absolute;
  z-index: -1;
  display: inline-block;
  overflow: hidden;
  width: 12px;
  height: 12px;
  left: -11px;
  right: initial;
  background-color: inherit;
  filter: blur(5upx);
  opacity: 0.3;
}

.cu-chat .cu-item&gt;.main .content:not([class*=&quot;bg-&quot;])::before {
  background-color: #333333;
  opacity: 0.1;
}

.cu-chat .cu-item.self&gt;.main .content::before {
  left: auto;
  right: -11px;
}

.cu-chat .cu-item.self {
  justify-content: flex-end;
  text-align: right;
}

.cu-chat .cu-info {
  display: inline-block;
  margin: 10px auto;
  font-size: 12px;
  padding: 4px 11px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  color: #ffffff;
  max-width: 400px;
  line-height: 1.4;
}

/* ==================
        卡片
==================== */

.cu-card {
  display: block;
  overflow: hidden;
}

.cu-card&gt;.cu-item {
  display: block;
  background-color: #ffffff;
  overflow: hidden;
  border-radius: 5px;
  margin: 15px;
}

.cu-card&gt;.cu-item.shadow-blur {
  overflow: initial;
}

.cu-card.no-card&gt;.cu-item {
  margin: 0px;
  border-radius: 0px;
}

.cu-card .grid.grid-square {
  margin-bottom: -10px;
}

.cu-card.case .image {
  position: relative;
}

.cu-card.case .image image {
  width: 100%;
}

.cu-card.case .image .cu-tag {
  position: absolute;
  right: 0;
  top: 0;
}

.cu-card.case .image .cu-bar {
  position: absolute;
  bottom: 0;
  width: 100%;
  background-color: transparent;
  padding: 0px 15px;
}

.cu-card.case.no-card .image {
  margin: 15px 15px 0;
  overflow: hidden;
  border-radius: 5px;
}

.cu-card.dynamic {
  display: block;
}

.cu-card.dynamic&gt;.cu-item {
  display: block;
  background-color: #ffffff;
  overflow: hidden;
}

.cu-card.dynamic&gt;.cu-item&gt;.text-content {
  padding: 0 15px 0;
  max-height: 6.4em;
  overflow: hidden;
  font-size: 15px;
  margin-bottom: 10px;
}

.cu-card.dynamic&gt;.cu-item .square-img {
  width: 100%;
  height: 200px;
  border-radius: 3px;
}

.cu-card.dynamic&gt;.cu-item .only-img {
  width: 100%;
  height: 310px;
  border-radius: 3px;
}

/* card.dynamic&gt;.cu-item .comment {
  padding: 10px;
  background-color: #f1f1f1;
  margin: 0 15px 15px;
  border-radius: 3px;
} */

.cu-card.article {
  display: block;
}

.cu-card.article&gt;.cu-item {
  padding-bottom: 15px;
}

.cu-card.article&gt;.cu-item .title {
  font-size: 15px;
  font-weight: 900;
  color: #333333;
  line-height: 50px;
  padding: 0 15px;
}

.cu-card.article&gt;.cu-item .content {
  display: flex;
  padding: 0 15px;
}

.cu-card.article&gt;.cu-item .content&gt;image {
  width: 220px;
  height: 6.4em;
  margin-right: 10px;
  border-radius: 3px;
}

.cu-card.article&gt;.cu-item .content .desc {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.cu-card.article&gt;.cu-item .content .text-content {
  font-size: 14px;
  color: #888;
  height: 4.8em;
  overflow: hidden;
}

/* ==================
        表单
==================== */

.cu-form-group {
  background-color: #ffffff;
  padding: 1px 15px;
  display: flex;
  align-items: center;
  min-height: 50px;
  justify-content: space-between;
}

.cu-form-group+.cu-form-group {
  border-top: 1px solid #eee;
}

.cu-form-group .title {
  text-align: justify;
  padding-right: 15px;
  font-size: 15px;
  position: relative;
  height: 30px;
  line-height: 30px;
}

.cu-form-group input {
  flex: 1;
  font-size: 15px;
  color: #555;
  padding-right: 10px;
}

.cu-form-group&gt;text[class*=&quot;cuIcon-&quot;] {
  font-size: 18px;
  padding: 0;
  box-sizing: border-box;
}

.cu-form-group textarea {
  margin: 16px 0 15px;
  height: 4.6em;
  width: 100%;
  line-height: 1.2em;
  flex: 1;
  font-size: 14px;
  padding: 0;
}

.cu-form-group.align-start .title {
  height: 1em;
  margin-top: 16px;
  line-height: 1em;
}

.cu-form-group picker {
  flex: 1;
  padding-right: 20px;
  overflow: hidden;
  position: relative;
}

.cu-form-group picker .picker {
  line-height: 50px;
  font-size: 14px;
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
  text-align: right;
}

.cu-form-group picker::after {
  font-family: cuIcon;
  display: block;
  content: &quot;\e6a3&quot;;
  position: absolute;
  font-size: 32px;
  color: #8799a3;
  line-height: 50px;
  width: 30px;
  text-align: center;
  top: 0;
  bottom: 0;
  right: -10px;
  margin: auto;
}

.cu-form-group textarea[disabled],
.cu-form-group textarea[disabled] .placeholder {
  color: transparent;
}

/* ==================
        模态窗口
==================== */

.cu-modal {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: 1110;
  opacity: 0;
  outline: 0;
  text-align: center;
  -ms-transform: scale(1.185);
  transform: scale(1.185);
  backface-visibility: hidden;
  perspective: 2000px;
  background: rgba(0, 0, 0, 0.6);
  transition: all 0.3s ease-in-out 0s;
  pointer-events: none;
}

.cu-modal::before {
  content: &quot;\200B&quot;;
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}

.cu-modal.show {
  opacity: 1;
  transition-duration: 0.3s;
  -ms-transform: scale(1);
  transform: scale(1);
  overflow-x: hidden;
  overflow-y: auto;
  pointer-events: auto;
}

.cu-dialog {
  position: relative;
  display: inline-block;
  vertical-align: middle;
  margin-left: auto;
  margin-right: auto;
  width: 640px;
  max-width: 100%;
  background-color: #f8f8f8;
  border-radius: 5px;
  overflow: hidden;
}

.cu-modal.bottom-modal::before {
  vertical-align: bottom;
}

.cu-modal.bottom-modal .cu-dialog {
  width: 100%;
  border-radius: 0;
}

.cu-modal.bottom-modal {
  margin-bottom: -1000px;
}

.cu-modal.bottom-modal.show {
  margin-bottom: 0;
}

.cu-modal.drawer-modal {
  transform: scale(1);
  display: flex;
}

.cu-modal.drawer-modal .cu-dialog {
  height: 100%;
  min-width: 200px;
  border-radius: 0;
  margin: initial;
  transition-duration: 0.3s;
}

.cu-modal.drawer-modal.justify-start .cu-dialog {
  transform: translateX(-100%);
}

.cu-modal.drawer-modal.justify-end .cu-dialog {
  transform: translateX(100%);
}

.cu-modal.drawer-modal.show .cu-dialog {
  transform: translateX(0%);
}
.cu-modal .cu-dialog&gt;.cu-bar:first-child .action{
  min-width: 100rpx;
  margin-right: 0;
  min-height: 100rpx;
}


/* ==================
          布局
==================== */

/*  -- flex弹性布局 -- */

.flex {
  display: flex;
}

.basis-xs {
  flex-basis: 20%;
}

.basis-sm {
  flex-basis: 40%;
}

.basis-df {
  flex-basis: 50%;
}

.basis-lg {
  flex-basis: 60%;
}

.basis-xl {
  flex-basis: 80%;
}

.flex-sub {
  flex: 1;
}

.flex-twice {
  flex: 2;
}

.flex-treble {
  flex: 3;
}

.flex-direction {
  flex-direction: column;
}

.flex-wrap {
  flex-wrap: wrap;
}

.align-start {
  align-items: flex-start;
}

.align-end {
  align-items: flex-end;
}

.align-center {
  align-items: center;
}

.align-stretch {
  align-items: stretch;
}

.self-start {
  align-self: flex-start;
}

.self-center {
  align-self: flex-center;
}

.self-end {
  align-self: flex-end;
}

.self-stretch {
  align-self: stretch;
}

.align-stretch {
  align-items: stretch;
}

.justify-start {
  justify-content: flex-start;
}

.justify-end {
  justify-content: flex-end;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

.justify-around {
  justify-content: space-around;
}

/* grid布局 */

.grid {
  display: flex;
  flex-wrap: wrap;
}

.grid.grid-square {
  overflow: hidden;
}

.grid.grid-square .cu-tag {
  position: absolute;
  right: 0;
  top: 0;
  border-bottom-left-radius: 3px;
  padding: 3px 11px;
  height: auto;
  background-color: rgba(0, 0, 0, 0.5);
}

.grid.grid-square&gt;view&gt;text[class*=&quot;cuIcon-&quot;] {
  font-size: 51px;
  position: absolute;
  color: #8799a3;
  margin: auto;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

.grid.grid-square&gt;view {
  margin-right: 10px;
  margin-bottom: 10px;
  border-radius: 3px;
  position: relative;
  overflow: hidden;
}
.grid.grid-square&gt;view.bg-img image {
  width: 100%;
  height: 100%;
  position: absolute;
}
.grid.col-1.grid-square&gt;view {
  padding-bottom: 100%;
  height: 0;
  margin-right: 0;
}

.grid.col-2.grid-square&gt;view {
  padding-bottom: calc((100% - 10px)/2);
  height: 0;
  width: calc((100% - 10px)/2);
}

.grid.col-3.grid-square&gt;view {
  padding-bottom: calc((100% - 20px)/3);
  height: 0;
  width: calc((100% - 20px)/3);
}

.grid.col-4.grid-square&gt;view {
  padding-bottom: calc((100% - 30px)/4);
  height: 0;
  width: calc((100% - 30px)/4);
}

.grid.col-5.grid-square&gt;view {
  padding-bottom: calc((100% - 40px)/5);
  height: 0;
  width: calc((100% - 40px)/5);
}

.grid.col-2.grid-square&gt;view:nth-child(2n),
.grid.col-3.grid-square&gt;view:nth-child(3n),
.grid.col-4.grid-square&gt;view:nth-child(4n),
.grid.col-5.grid-square&gt;view:nth-child(5n) {
  margin-right: 0;
}

.grid.col-1&gt;view {
  width: 100%;
}

.grid.col-2&gt;view {
  width: 50%;
}

.grid.col-3&gt;view {
  width: 33.33%;
}

.grid.col-4&gt;view {
  width: 25%;
}

.grid.col-5&gt;view {
  width: 20%;
}

/*  -- 内外边距 -- */

.margin-0 {
  margin: 0;
}

.margin-xs {
  margin: 5px;
}

.margin-sm {
  margin: 10px;
}

.margin {
  margin: 15px;
}

.margin-lg {
  margin: 20px;
}

.margin-xl {
  margin: 25px;
}

.margin-top-xs {
  margin-top: 5px;
}

.margin-top-sm {
  margin-top: 10px;
}

.margin-top {
  margin-top: 15px;
}

.margin-top-lg {
  margin-top: 20px;
}

.margin-top-xl {
  margin-top: 25px;
}

.margin-right-xs {
  margin-right: 5px;
}

.margin-right-sm {
  margin-right: 10px;
}

.margin-right {
  margin-right: 15px;
}

.margin-right-lg {
  margin-right: 20px;
}

.margin-right-xl {
  margin-right: 25px;
}

.margin-bottom-xs {
  margin-bottom: 5px;
}

.margin-bottom-sm {
  margin-bottom: 10px;
}

.margin-bottom {
  margin-bottom: 15px;
}

.margin-bottom-lg {
  margin-bottom: 20px;
}

.margin-bottom-xl {
  margin-bottom: 25px;
}

.margin-left-xs {
  margin-left: 5px;
}

.margin-left-sm {
  margin-left: 10px;
}

.margin-left {
  margin-left: 15px;
}

.margin-left-lg {
  margin-left: 20px;
}

.margin-left-xl {
  margin-left: 25px;
}

.margin-lr-xs {
  margin-left: 5px;
  margin-right: 5px;
}

.margin-lr-sm {
  margin-left: 10px;
  margin-right: 10px;
}

.margin-lr {
  margin-left: 15px;
  margin-right: 15px;
}

.margin-lr-lg {
  margin-left: 20px;
  margin-right: 20px;
}

.margin-lr-xl {
  margin-left: 25px;
  margin-right: 25px;
}

.margin-tb-xs {
  margin-top: 5px;
  margin-bottom: 5px;
}

.margin-tb-sm {
  margin-top: 10px;
  margin-bottom: 10px;
}

.margin-tb {
  margin-top: 15px;
  margin-bottom: 15px;
}

.margin-tb-lg {
  margin-top: 20px;
  margin-bottom: 20px;
}

.margin-tb-xl {
  margin-top: 25px;
  margin-bottom: 25px;
}

.padding-0 {
  padding: 0;
}

.padding-xs {
  padding: 5px;
}

.padding-sm {
  padding: 10px;
}

.padding {
  padding: 15px;
}

.padding-lg {
  padding: 20px;
}

.padding-xl {
  padding: 25px;
}

.padding-top-xs {
  padding-top: 5px;
}

.padding-top-sm {
  padding-top: 10px;
}

.padding-top {
  padding-top: 15px;
}

.padding-top-lg {
  padding-top: 20px;
}

.padding-top-xl {
  padding-top: 25px;
}

.padding-right-xs {
  padding-right: 5px;
}

.padding-right-sm {
  padding-right: 10px;
}

.padding-right {
  padding-right: 15px;
}

.padding-right-lg {
  padding-right: 20px;
}

.padding-right-xl {
  padding-right: 25px;
}

.padding-bottom-xs {
  padding-bottom: 5px;
}

.padding-bottom-sm {
  padding-bottom: 10px;
}

.padding-bottom {
  padding-bottom: 15px;
}

.padding-bottom-lg {
  padding-bottom: 20px;
}

.padding-bottom-xl {
  padding-bottom: 25px;
}

.padding-left-xs {
  padding-left: 5px;
}

.padding-left-sm {
  padding-left: 10px;
}

.padding-left {
  padding-left: 15px;
}

.padding-left-lg {
  padding-left: 20px;
}

.padding-left-xl {
  padding-left: 25px;
}

.padding-lr-xs {
  padding-left: 5px;
  padding-right: 5px;
}

.padding-lr-sm {
  padding-left: 10px;
  padding-right: 10px;
}

.padding-lr {
  padding-left: 15px;
  padding-right: 15px;
}

.padding-lr-lg {
  padding-left: 20px;
  padding-right: 20px;
}

.padding-lr-xl {
  padding-left: 25px;
  padding-right: 25px;
}

.padding-tb-xs {
  padding-top: 5px;
  padding-bottom: 5px;
}

.padding-tb-sm {
  padding-top: 10px;
  padding-bottom: 10px;
}

.padding-tb {
  padding-top: 15px;
  padding-bottom: 15px;
}

.padding-tb-lg {
  padding-top: 20px;
  padding-bottom: 20px;
}

.padding-tb-xl {
  padding-top: 25px;
  padding-bottom: 25px;
}

/* -- 浮动 --  */

.cf::after,
.cf::before {
  content: &quot; &quot;;
  display: table;
}

.cf::after {
  clear: both;
}

.fl {
  float: left;
}

.fr {
  float: right;
}

/* ==================
          背景
==================== */

.line-red::after,
.lines-red::after {
  border-color: #e54d42;
}

.line-orange::after,
.lines-orange::after {
  border-color: #f37b1d;
}

.line-yellow::after,
.lines-yellow::after {
  border-color: #fbbd08;
}

.line-olive::after,
.lines-olive::after {
  border-color: #8dc63f;
}

.line-green::after,
.lines-green::after {
  border-color: #39b54a;
}

.line-cyan::after,
.lines-cyan::after {
  border-color: #1cbbb4;
}

.line-blue::after,
.lines-blue::after {
  border-color: #0081ff;
}

.line-purple::after,
.lines-purple::after {
  border-color: #6739b6;
}

.line-mauve::after,
.lines-mauve::after {
  border-color: #9c26b0;
}

.line-pink::after,
.lines-pink::after {
  border-color: #e03997;
}

.line-brown::after,
.lines-brown::after {
  border-color: #a5673f;
}

.line-grey::after,
.lines-grey::after {
  border-color: #8799a3;
}

.line-gray::after,
.lines-gray::after {
  border-color: #aaaaaa;
}

.line-black::after,
.lines-black::after {
  border-color: #333333;
}

.line-white::after,
.lines-white::after {
  border-color: #ffffff;
}

.bg-red {
  background-color: #e54d42;
  color: #ffffff;
}

.bg-orange {
  background-color: #f37b1d;
  color: #ffffff;
}

.bg-yellow {
  background-color: #fbbd08;
  color: #333333;
}

.bg-olive {
  background-color: #8dc63f;
  color: #ffffff;
}

.bg-green {
  background-color: #39b54a;
  color: #ffffff;
}

.bg-cyan {
  background-color: #1cbbb4;
  color: #ffffff;
}

.bg-blue {
  background-color: #0081ff;
  color: #ffffff;
}

.bg-purple {
  background-color: #6739b6;
  color: #ffffff;
}

.bg-mauve {
  background-color: #9c26b0;
  color: #ffffff;
}

.bg-pink {
  background-color: #e03997;
  color: #ffffff;
}

.bg-brown {
  background-color: #a5673f;
  color: #ffffff;
}

.bg-grey {
  background-color: #8799a3;
  color: #ffffff;
}

.bg-gray {
  background-color: #f0f0f0;
  color: #333333;
}

.bg-black {
  background-color: #333333;
  color: #ffffff;
}
.bg-black-im {
  background-color: #333333!important;
  color: #ffffff;
}

.bg-white {
  background-color: #ffffff;
  color: #666666;
}

.bg-shadeTop {
  background-image: linear-gradient(rgba(0, 0, 0, 1), rgba(0, 0, 0, 0.01));
  color: #ffffff;
}

.bg-shadeBottom {
  background-image: linear-gradient(rgba(0, 0, 0, 0.01), rgba(0, 0, 0, 1));
  color: #ffffff;
}

.bg-red.light {
  color: #e54d42;
  background-color: #fadbd9;
}

.bg-orange.light {
  color: #f37b1d;
  background-color: #fde6d2;
}

.bg-yellow.light {
  color: #fbbd08;
  background-color: #fef2ced2;
}

.bg-olive.light {
  color: #8dc63f;
  background-color: #e8f4d9;
}

.bg-green.light {
  color: #39b54a;
  background-color: #d7f0dbff;
}

.bg-cyan.light {
  color: #1cbbb4;
  background-color: #d2f1f0;
}

.bg-blue.light {
  color: #0081ff;
  background-color: #cce6ff;
}

.bg-purple.light {
  color: #6739b6;
  background-color: #e1d7f0;
}

.bg-mauve.light {
  color: #9c26b0;
  background-color: #ebd4ef;
}

.bg-pink.light {
  color: #e03997;
  background-color: #f9d7ea;
}

.bg-brown.light {
  color: #a5673f;
  background-color: #ede1d9;
}

.bg-grey.light {
  color: #8799a3;
  background-color: #e7ebed;
}

.bg-gradual-red {
  background-image: linear-gradient(45deg, #f43f3b, #ec008c);
  color: #ffffff;
}

.bg-gradual-orange {
  background-image: linear-gradient(45deg, #ff9700, #ed1c24);
  color: #ffffff;
}

.bg-gradual-green {
  background-image: linear-gradient(45deg, #39b54a, #8dc63f);
  color: #ffffff;
}

.bg-gradual-purple {
  background-image: linear-gradient(45deg, #9000ff, #5e00ff);
  color: #ffffff;
}

.bg-gradual-pink {
  background-image: linear-gradient(45deg, #ec008c, #6739b6);
  color: #ffffff;
}

.bg-gradual-blue {
  background-image: linear-gradient(45deg, #0081ff, #1cbbb4);
  color: #ffffff;
}

.shadow[class*=&quot;-red&quot;] {
  box-shadow: 3px 3px 4px rgba(204, 69, 59, 0.2);
}

.shadow[class*=&quot;-orange&quot;] {
  box-shadow: 3px 3px 4px rgba(217, 109, 26, 0.2);
}

.shadow[class*=&quot;-yellow&quot;] {
  box-shadow: 3px 3px 4px rgba(224, 170, 7, 0.2);
}

.shadow[class*=&quot;-olive&quot;] {
  box-shadow: 3px 3px 4px rgba(124, 173, 55, 0.2);
}

.shadow[class*=&quot;-green&quot;] {
  box-shadow: 3px 3px 4px rgba(48, 156, 63, 0.2);
}

.shadow[class*=&quot;-cyan&quot;] {
  box-shadow: 3px 3px 4px rgba(28, 187, 180, 0.2);
}

.shadow[class*=&quot;-blue&quot;] {
  box-shadow: 3px 3px 4px rgba(0, 102, 204, 0.2);
}

.shadow[class*=&quot;-purple&quot;] {
  box-shadow: 3px 3px 4px rgba(88, 48, 156, 0.2);
}

.shadow[class*=&quot;-mauve&quot;] {
  box-shadow: 3px 3px 4px rgba(133, 33, 150, 0.2);
}

.shadow[class*=&quot;-pink&quot;] {
  box-shadow: 3px 3px 4px rgba(199, 50, 134, 0.2);
}

.shadow[class*=&quot;-brown&quot;] {
  box-shadow: 3px 3px 4px rgba(140, 88, 53, 0.2);
}

.shadow[class*=&quot;-grey&quot;] {
  box-shadow: 3px 3px 4px rgba(114, 130, 138, 0.2);
}

.shadow[class*=&quot;-gray&quot;] {
  box-shadow: 3px 3px 4px rgba(114, 130, 138, 0.2);
}

.shadow[class*=&quot;-black&quot;] {
  box-shadow: 3px 3px 4px rgba(26, 26, 26, 0.2);
}

.shadow[class*=&quot;-white&quot;] {
  box-shadow: 3px 3px 4px rgba(26, 26, 26, 0.2);
}

.text-shadow[class*=&quot;-red&quot;] {
  text-shadow: 3px 3px 4px rgba(204, 69, 59, 0.2);
}

.text-shadow[class*=&quot;-orange&quot;] {
  text-shadow: 3px 3px 4px rgba(217, 109, 26, 0.2);
}

.text-shadow[class*=&quot;-yellow&quot;] {
  text-shadow: 3px 3px 4px rgba(224, 170, 7, 0.2);
}

.text-shadow[class*=&quot;-olive&quot;] {
  text-shadow: 3px 3px 4px rgba(124, 173, 55, 0.2);
}

.text-shadow[class*=&quot;-green&quot;] {
  text-shadow: 3px 3px 4px rgba(48, 156, 63, 0.2);
}

.text-shadow[class*=&quot;-cyan&quot;] {
  text-shadow: 3px 3px 4px rgba(28, 187, 180, 0.2);
}

.text-shadow[class*=&quot;-blue&quot;] {
  text-shadow: 3px 3px 4px rgba(0, 102, 204, 0.2);
}

.text-shadow[class*=&quot;-purple&quot;] {
  text-shadow: 3px 3px 4px rgba(88, 48, 156, 0.2);
}

.text-shadow[class*=&quot;-mauve&quot;] {
  text-shadow: 3px 3px 4px rgba(133, 33, 150, 0.2);
}

.text-shadow[class*=&quot;-pink&quot;] {
  text-shadow: 3px 3px 4px rgba(199, 50, 134, 0.2);
}

.text-shadow[class*=&quot;-brown&quot;] {
  text-shadow: 3px 3px 4px rgba(140, 88, 53, 0.2);
}

.text-shadow[class*=&quot;-grey&quot;] {
  text-shadow: 3px 3px 4px rgba(114, 130, 138, 0.2);
}

.text-shadow[class*=&quot;-gray&quot;] {
  text-shadow: 3px 3px 4px rgba(114, 130, 138, 0.2);
}

.text-shadow[class*=&quot;-black&quot;] {
  text-shadow: 3px 3px 4px rgba(26, 26, 26, 0.2);
}

.bg-img {
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

.bg-mask {
  background-color: #333333;
  position: relative;
}

.bg-mask::after {
  content: &quot;&quot;;
  border-radius: inherit;
  width: 100%;
  height: 100%;
  display: block;
  background-color: rgba(0, 0, 0, 0.4);
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  top: 0;
}


/* ==================
          文本
==================== */

.text-xs {
  font-size: 10px;
}

.text-sm {
  font-size: 12px;
}

.text-df {
  font-size: 14px;
}

.text-lg {
  font-size: 16px;
}

.text-xl {
  font-size: 18px;
}

.text-xxl {
  font-size: 22px;
}

.text-sl {
  font-size: 40px;
}

.text-xsl {
  font-size: 110px;
}

.text-Abc {
  text-transform: Capitalize;
}

.text-ABC {
  text-transform: Uppercase;
}

.text-abc {
  text-transform: Lowercase;
}

.text-price::before {
  content: &quot;¥&quot;;
  font-size: 80%;
  margin-right: 2px;
}

.text-cut {
  text-overflow: ellipsis;
  white-space: nowrap;
  overflow: hidden;
}
.text-cut-line3 {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  overflow: hidden;
}

.text-underline {
  text-decoration: underline;
}
.text-delet {
  text-decoration: line-through; 
}

.text-bold {
  font-weight: bold;
}

.text-center {
  text-align: center;
}

.text-content {
  line-height: 1.6;
}

.text-left {
  text-align: left;
}

.text-right {
  text-align: right;
}

.text-red,
.line-red,
.lines-red {
  color: #e54d42;
}

.text-orange,
.line-orange,
.lines-orange {
  color: #f37b1d;
}

.text-yellow,
.line-yellow,
.lines-yellow {
  color: #fbbd08;
}

.text-olive,
.line-olive,
.lines-olive {
  color: #8dc63f;
}

.text-green,
.line-green,
.lines-green {
  color: #39b54a;
}

.text-cyan,
.line-cyan,
.lines-cyan {
  color: #1cbbb4;
}

.text-blue,
.line-blue,
.lines-blue {
  color: #0081ff;
}

.text-purple,
.line-purple,
.lines-purple {
  color: #6739b6;
}

.text-mauve,
.line-mauve,
.lines-mauve {
  color: #9c26b0;
}

.text-pink,
.line-pink,
.lines-pink {
  color: #e03997;
}

.text-brown,
.line-brown,
.lines-brown {
  color: #a5673f;
}

.text-grey,
.line-grey,
.lines-grey {
  color: #8799a3;
}

.text-gray,
.line-gray,
.lines-gray {
  color: #aaaaaa;
}

.text-black,
.line-black,
.lines-black {
  color: #333333;
}

.text-white,
.line-white,
.lines-white {
  color: #ffffff;
}</code></pre>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>scss</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue简单教程</title>
    <url>/posts/3546721507.html</url>
    <content><![CDATA[<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>  安装Node.js<br>  <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node官网下载</a></p>
<p>  安装vue：<br>  npm install vue</p>
<p>  安装webpack使用：<br>  npm npm install webpack -g</p>
<p>  安装vue-cli使用：<br>  npm install vue-cli -g</p>
<p>  新建基于webpack的vue-cli使用：<br>  vue init webpack myProject(项目名称)<br>  这里需要进行一些配置，默认回车</p>
<p>  进入项目根目录，初始化项目使用：<br>  cd myProject<br>  npm install</p>
<p>  运行项目使用：<br>  npm run dev</p>
<h4 id="vue目录介绍"><a href="#vue目录介绍" class="headerlink" title="vue目录介绍"></a>vue目录介绍</h4><ul>
<li>build：项目构建(webpack)相关代码</li>
<li>config：配置目录，包括端口号等。我们初学可以使用默认的。</li>
<li>src：这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：<ul>
<li>assets: 放置一些图片，如logo等。</li>
<li>components: 目录里面放了一个组件文件，可以不用。</li>
<li>App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</li>
<li>main.js: 项目的核心文件。</li>
</ul>
</li>
<li>static：</li>
<li>test：初始测试目录</li>
<li>.xxxx文件：这些是一些配置文件，包括语法配置，git配置等。</li>
<li>index.html：首页入口文件，你可以添加一些 meta 信息或统计代码等。</li>
<li>package.json：项目配置文件。</li>
<li>README.md：项目的说明文档，markdown 格式</li>
</ul>
<h4 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h4><p>  什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！<br>  生命周期钩子 = 生命周期函数 = 生命周期事件<br>  主要的生命周期函数分类：</p>
<ul>
<li>创建期间的生命周期函数：<ol>
<li>beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性</li>
<li>created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板</li>
<li>beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中</li>
<li>mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示</li>
</ol>
</li>
<li>运行期间的生命周期函数：<ol start="5">
<li>beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！</li>
</ol>
</li>
<li>销毁期间的生命周期函数：<ol start="7">
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ol>
</li>
</ul>
<h4 id="Vue-router的的安装使用"><a href="#Vue-router的的安装使用" class="headerlink" title="Vue-router的的安装使用"></a>Vue-router的的安装使用</h4><p>Vue.js 路由允许我们通过不同的 URL 访问不同的内容。<br>通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。<br>Vue.js 路由需要载入 vue-router 库</p>
<p>npm 命令行安装vuevue-router：</p>
<ul>
<li>npm install vue-router<br>安装完成后，在main.js中引入vue-router</li>
</ul>
<p>因为用的vue-cli所以不需要安装，直接生成router文件目录以及其中index.js<br>在main.js中是直接引用router文件</p>
<pre><code>import router from &apos;./router&apos;
new Vue({
  el: &apos;#app&apos;,
  router,//此为简写，实际为router:router
  components: { App },
  template: &apos;&lt;App/&gt;&apos;
})</code></pre><p>在router文件目录下的index.js中</p>
<pre><code>import Vue from &apos;vue&apos;
import Router from &apos;vue-router&apos;</code></pre><p>Vue.use(Router),并且在vue对象属性中使用</p>
<pre><code>const router = new Router({
  //默认hash 模式，使用history,去掉路由前的#
  mode: &apos;history&apos;,
  routes: [
    {
      redirect: {name: &apos;childHome&apos;}, // 重定向，使用name或者path方式{/home}
      name: &apos;home&apos;, // 命名使用
      path: &apos;/home&apos;, // 路由路径使用
      component: () =&gt; import(&apos;@/components/home&apos;), // 按需加载方式
      meta: {
        title: &apos;首页&apos; // 可设置页面title
      },
      //children属性做路由嵌套，在home文件中设置router-view，父级页面重定向到这个子页面
      children: [
        name: &apos;childHome&apos;, // 命名使用
        path: &apos;/childHome&apos;, // 子页面path加 /为根路径,子页面path不加 / 为嵌套路径
        component: () =&gt; import(&apos;@/components/home/childHome&apos;), // 按需加载方式
        meta: {
          title: &apos;嵌套页面&apos;
        }
      ]
    }
  ]
})
export default router</code></pre><p>Vue-router使用history模式，后台配合</p>
<p>  要用这种模式，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://url/router" target="_blank" rel="noopener">http://url/router</a> ，就会返回 404，出现以上事故。<br>  如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你下面项目依赖的页面。<br>目前我是使用tomcat，解决方法如下：<br>tomcat 目录下免得conf文件夹里面的web.xml文件加上下面的配置</p>
<pre><code>&lt;display-name&gt;webapp&lt;/display-name&gt;
  &lt;description&gt;
    webapp
  &lt;/description&gt;
  &lt;error-page&gt;
  &lt;error-code&gt;404&lt;/error-code&gt;
  &lt;location&gt;/&lt;/location&gt;
&lt;/error-page&gt;</code></pre><p>Vue-router的beforeEach与afterEach钩子函数<br>在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。<br>定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。<br>vue提供了三大类钩子：</p>
<ul>
<li>全局钩子</li>
<li>某个路由的钩子</li>
<li>组件内钩子<br>两种函数：</li>
<li>Vue.beforeEach(function(to,form,next){}) /<em>在跳转之前执行</em>/</li>
<li>Vue.afterEach(function(to,form)) /<em>在跳转之后判断</em>/</li>
</ul>
<p>beforeEach函数有三个参数：</p>
<ul>
<li>to:router即将进入的路由对象</li>
<li>from:当前导航即将离开的路由</li>
<li>next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。</li>
</ul>
<p>afterEach函数不用传next()函数</p>
<p>全局钩子函数</p>
<pre><code>router.beforeEach((to, from, next) =&gt; {
  // 路由切换，加载动画开始
  LoadingBar.start()
  //pc端一般不改变title，移动端使用改变页面title
  if (to.meta.title) {
    document.title = to.meta.title
  }
  let token = localStorage.getItem(&apos;token&apos;)
    if (!token) {
      // token为空则跳转登录
      next(&apos;/login&apos;)
    } else {
      return next()
    }
  return next()
})
router.afterEach((to, from) =&gt; {
  // 加载动画停止
  LoadingBar.finish()
})</code></pre><p>router-link相关属性</p>
<ul>
<li>to<br>表示目标路由的链接。 当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象</li>
<li>replace<br>设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录</li>
<li>append<br>设置 append 属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b</li>
<li>tag<br>有时候想要 router-link 渲染成某种标签，例如 li 。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。<br>根据路由跳转添加class方式<br>在css设置.active.router-link-active {color: #358ee7;}<br>在 router-link 中添加class=”active”,则路由跳转到此页面时class生效</li>
</ul>
<p>路由过渡动效</p>
<pre><code>&lt;router-link&gt; 是基本的动态组件，所以我们可以用 &lt;transition&gt; 组件给它添加一些过渡效果：
&lt;transition  name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; 
  &lt;router-view/&gt;
&lt;/transition&gt;</code></pre><p>CSS设置</p>
<pre><code>.fade-enter-active, .fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}</code></pre><p>指令方法更改路由<br>router.push(location, onComplete?, onAbort?)<br>// 字符串<br>router.push(‘home’)<br>// 对象<br>router.push({ path: ‘home’ })<br>// 命名的路由<br>router.push({ name: ‘user’, params: { userId: ‘123’ }})<br>// 带查询参数，变成 /register?plan=private<br>router.push({ path: ‘register’, query: { plan: ‘private’ }})<br>注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：<br>const userId = ‘123’<br>router.push({ name: ‘user’, params: { userId }}) // -&gt; /user/123<br>router.push({ path: <code>/user/${userId}</code> }) // -&gt; /user/123<br>// 这里的 params 不生效<br>router.push({ path: ‘/user’, params: { userId }}) // -&gt; /user<br>同样的规则也适用于 router-link 组件的 to 属性。</p>
<p>router.replace(location, onComplete?, onAbort?)<br>跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<p>router.go(n)<br>// 在浏览器记录中前进一步，等同于 history.forward()<br>router.go(1)<br>// 后退一步记录，等同于 history.back()<br>router.go(-1)<br>// 前进 3 步记录<br>router.go(3)<br>// 如果 history 记录不够用，则失败<br>router.go(-100)<br>router.go(100)</p>
<h4 id="Vuex核心概念"><a href="#Vuex核心概念" class="headerlink" title="Vuex核心概念"></a>Vuex核心概念</h4><ul>
<li>state</li>
<li>getters</li>
<li>mutations</li>
<li>actions</li>
<li>modules</li>
</ul>
<ul>
<li>修改state的唯一方法是提交mutation,但是mutations中方法是同步的,actions可以提交mutations.</li>
</ul>
<h4 id="预渲染-prerender-spa-plugin"><a href="#预渲染-prerender-spa-plugin" class="headerlink" title="预渲染 prerender-spa-plugin"></a>预渲染 prerender-spa-plugin</h4><ul>
<li>SEO优化使用</li>
<li>npm i prerender-spa-plugin -D</li>
</ul>
<h4 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 SSR"></a>服务端渲染 SSR</h4><ul>
<li>vue-server-renderer</li>
<li>npm i vue-server-renderer -S</li>
</ul>
<h4 id="vue项目初次加载动画"><a href="#vue项目初次加载动画" class="headerlink" title="vue项目初次加载动画"></a>vue项目初次加载动画</h4><p>首次加载太慢，进行感知优化,在入口的html文件里直接添加loading加载提示，让它在页面刚开始加载的时候默认显示，而隐藏主页面的root标签。<br>再在vue项目的入口vue里的created或mounted里将加载提示的标签删除或隐藏，再将主页面root标签显示。<br>入口HTML文件index.html：</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
  #appLoading { width: 100%; height: 100%; }
  #appLoading img {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300px;
    height: 300px;
    -webkit-transform: translateY(-50%)  translateX(-50%);
    transform: translateY(-50%)  translateX(-50%);
  }
&lt;/style&gt;
&lt;body&gt;
  &lt;div id=&quot;appLoading&quot;&gt;
    &lt;img src=&quot;/static/img/loading.gif&quot; alt=&quot;loading&quot; /&gt;
  &lt;/div&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;/body&gt;</code></pre><p>入口vue文件App.vue：</p>
<pre><code>&lt;script&gt;
  export default {
    name: &apos;app&apos;,
    created () {
      try {
        document.body.removeChild(document.getElementById(&apos;appLoading&apos;))
        setTimeout(function () {
          document.getElementById(&apos;app&apos;).style.display = &apos;block&apos;
        }, 500)
      } catch (e) {
      }
    }
  }
&lt;/script&gt;</code></pre>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>VueRouter</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>express服务端开发</title>
    <url>/posts/1524237778.html</url>
    <content><![CDATA[<h3 id="安装express"><a href="#安装express" class="headerlink" title="安装express"></a>安装express</h3><pre><code>已搭建好node环境,安装好mongodb数据库的情况下，安装express以及必要插件
npm i express -S
npm i body-parser -S
npm i cors -S</code></pre><h3 id="使用express"><a href="#使用express" class="headerlink" title="使用express"></a>使用express</h3><ul>
<li>新建一个项目文件夹nodeServer，在文件夹中新建一个server.js,内容如下</li>
</ul>
<pre><code>const express = require(&apos;express&apos;)
const bodyparser = require(&apos;body-parser&apos;)
const app = express()

// 解析表单数据 x-www-form-urlencode
app.use(bodyparser.urlencoded({ extended: false }))
// 解决跨域
app.use(cors())
// 解析json数据
app.use(bodyparser.json())

app.get(&apos;/user/login&apos;,(req, res) =&gt; {
  let {user,psw} = req.query
  if(user == &apos;admin&apos; &amp;&amp; psw == &apos;123456&apos;){
    res.send({err: 0, msg: &apos;login OK&apos;})
  }else{
    res.send({err: -1, msg: &apos;login error&apos;})
  }
})

// post消息体需要第三方插件解析，body-parser
app.post(&apos;/user/register&apos;,(req, res) =&gt; {
  let {user,psw} = req.body
  if(user == &apos;admin&apos; &amp;&amp; psw == &apos;123456&apos;){
    res.send({err: 0, msg: &apos;register OK&apos;})
  }else{
    res.send({err: -1, msg: &apos;register error&apos;})
  }
})

app.listen(3000, () =&gt; {
  console.log(&apos;server start&apos;)
})</code></pre><p>  在当前目录的终端中输入node server.js启动服务，简单的get、post服务器接口就完成了。</p>
<h3 id="设置静态目录"><a href="#设置静态目录" class="headerlink" title="设置静态目录"></a>设置静态目录</h3><pre><code>// 将当前目录的static文件夹设置问静态目录public
app.use(&apos;/public&apos;, express.static(path.join(__dirname, &apos;./static&apos;)))</code></pre><h3 id="api文档"><a href="#api文档" class="headerlink" title="api文档"></a>api文档</h3><ul>
<li>使用apidoc,自动生成api文档</li>
<li><a href="https://apidocjs.com/" target="_blank" rel="noopener">官方文档</a></li>
</ul>
<pre><code>// 安装
npm i apidoc -g</code></pre><ul>
<li>在你的项目根目录下新建apidoc.json文件，该文件描述了项目对外提供接口的概要信息如名称、版本、描述、文档打开时浏览器显示标题和接口缺省访问地址。</li>
</ul>
<pre><code>{
  &quot;name&quot;: &quot;ServiceAPI&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;XXX接口文档&quot;,
  &quot;title&quot;: &quot;ServiceAPI&quot;,
  &quot;url&quot; : &quot;http://xxx&quot;
}</code></pre><ul>
<li>使用样例</li>
</ul>
<pre><code>/**
* @api {post} /user/reg 用户注册
* @apiName reg
* @apiGroup user
*
* @apiParam {String} us 用户名
* @apiParam {String} ps 密码
* @apiParam {String} code 验证码
*
* @apiSuccess {String} err: 0 注册成功
* 
*/
router.post(&apos;/reg&apos;, (req, res) =&gt; {
  // 获取数据
  let { us, ps, code } = req.body
  if (us &amp;&amp; ps &amp;&amp; code) {
    // 判断验证码是否正确
    if(codes[us] != code){
      return res.send({ err: -2, message: &apos;验证码错误&apos; })
    }
    User.find({ us })
      .then(data =&gt; {
        if (data.length === 0) {
          return User.insertMany({ us, ps })
        } else {
        res.send({ err: -2, message: &apos;用户名已存在&apos; })
        }
      })
      .then(data =&gt; {
        res.send({ err: 0, message: &apos;注册ok&apos; })
      })
      .catch((err) =&gt; {
        res.send({ err: -1, message: &apos;注册失败&apos; })
      })
  } else {
    return res.send({ err: -1, message: &apos;参数错误&apos; })
  }
})</code></pre><ul>
<li>生成文档<br>cd到apidoc.json所在路径（即项目根目录）执行如下命令即可</li>
</ul>
<pre><code>apidoc -i src/ -o apidoc/</code></pre><p>  执行成功后会生成apidoc文件夹，点开apidoc文件夹中index.html会发现已经生成api文档</p>
<h3 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h3><ul>
<li>安装mongoose</li>
</ul>
<pre><code>npm i mongoose -S</code></pre><ul>
<li>在根目录新建db文件夹，然后db文件夹中新建model目录以及connect.js文件，内容如下</li>
</ul>
<pre><code>const mongoose = require(&apos;mongoose&apos;)
const db = &apos;mongodb://localhost/testdb&apos;

exports.connect = () =&gt; {
  // 连接数据库
  mongoose.connect(db, { useNewUrlParser: true, useUnifiedTopology: true })
  let maxConnectTimes = 0

  return new Promise((resolve, reject) =&gt; {
    // 数据库监听事件
    mongoose.connection.on(&apos;disconnected&apos;, () =&gt; {
      console.log(&apos;数据库断开重连&apos;)
      if(maxConnectTimes &lt;= 3){
        maxConnectTimes++
        mongoose.connect(db)
      }else{
        reject()
        throw new Error(&apos;数据库出现问题，请人为处理&apos;)
      }
    })

    mongoose.connection.on(&apos;error&apos;, (err) =&gt; {
      console.log(&apos;数据库断开重连&apos;)
      if(maxConnectTimes &lt;= 3){
        maxConnectTimes++
        mongoose.connect(db)
      }else{
        reject(err)
        throw new Error(&apos;数据库出现问题，请人为处理&apos;)
      }
    })

    mongoose.connection.once(&apos;open&apos;, () =&gt; {
      console.log(&apos;数据库连接成功&apos;)
      resolve()
    })
  })
}</code></pre><ul>
<li>在model目录下新建userModel.js内容如下</li>
</ul>
<pre><code>const mongoose = require(&apos;mongoose&apos;)
const Schema = mongoose.Schema
const userSchema = new mongoose.Schema({
  userID: Schema.Types.ObjectID,
  account: {type: String, required: true},
  password: {type: String, required: true},
  name: {type: String, required: true},
  sex: {type: Number, default: 0},
  createAt: {type: Date, default: Date.now()}
}, { collection: &apos;user&apos; })
// collection将mongodb默认取名方式改为指定名

// 改数据对象和集合关联(&apos;集合名&apos;, schema对象)
module.exports = mongoose.model(&apos;user&apos;, userSchema)</code></pre><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><ul>
<li>在根目录新建一个router目录，在router中新建userRouter.js内容如下</li>
</ul>
<pre><code>const express = require(&apos;express&apos;)
const router = express.Router()
const User = require(&apos;../db/model/userModel&apos;)

router.post(&apos;/login&apos;, (req, res) =&gt; {
  let { us, ps } = req.body
  if (!us &amp;&amp; !ps) { return res.send({ err: -1, message: &apos;参数错误&apos; }) }
  User.find({ us, ps })
    .then(data =&gt; {
      if (data.length &gt; 0) {
        res.send({ err: 0, message: &apos;登录成功&apos; })
      } else {
        res.send({ err: -2, message: &apos;用户名或密码不正确&apos; })
      }
    })
    .catch(err =&gt; {
      return res.send({ err: -1, message: &apos;内部错误&apos; })
    })
})
module.exports = router</code></pre><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><ul>
<li>server.js内容如下</li>
</ul>
<pre><code>const express = require(&apos;express&apos;)
const {connect} = require(&apos;./db/connect&apos;)
const path = require(&apos;path&apos;)
const app = express()
const cors = require(&apos;cors&apos;)

const bodyparser = require(&apos;body-parser&apos;)
// 解析表单数据 x-www-form-urlencode
app.use(bodyparser.urlencoded({ extended: false }))
// 解析json数据
app.use(bodyparser.json())
// 解决跨域
app.use(cors())
// 设置静态目录
app.use(&apos;/public&apos;, express.static(path.join(__dirname, &apos;./static&apos;)))

const userRouter = require(&apos;./router/userRouter&apos;)
app.use(&apos;/user&apos;, userRouter)

// 立即执行函数,连接数据库
;(async () =&gt; {
  await connect()
})()

app.listen(3000, () =&gt; {
  console.log(&apos;server start, port: 3000&apos;)
})</code></pre>]]></content>
      <categories>
        <category>express</category>
      </categories>
      <tags>
        <tag>express</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建教程</title>
    <url>/posts/2982906081.html</url>
    <content><![CDATA[<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ol>
<li><p>安装Git<br><a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git官网下载</a></p>
</li>
<li><p>安装Node.js<br><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node官网下载</a></p>
</li>
<li><p>安装Hexo<br><a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Git地址</a></p>
<p>npm i -g hexo-cli</p>
</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>新建一个blog文件夹，存放项目文件。</li>
<li>命令行cd到blog目录下，输入hexo init初始化，然后npm i安装必备的组件。</li>
<li>输入hexo g生成静态网页，然后输入hexo s打开本地服务器。</li>
<li>浏览器打开【<a href="http://localhost:4000/】" target="_blank" rel="noopener">http://localhost:4000/】</a> 就可以看到初始化的博客。</li>
</ol>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：模版文件。当你创建一篇新的文章时，hexo会依据模版文件进行创建，主要用在你想在每篇文章都添加一些共性的内容的情况下。</li>
<li>source：用来存放你的文章。除了文章还有一些主要的资源，比如文章里的图片，文件等等东西。这个文件夹最好定期做一个备份，丢了它，整个站点就废了。</li>
<li>themes：主题文件夹</li>
<li>_config.yml 站点配置文件。很多全局配置都在这个文件中。</li>
<li>package.json 应用数据。可以看出hexo版本信息，以及它所默认或者说依赖的一些组件。</li>
</ul>
<h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>  <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰Git教程</a></p>
<ol>
<li>注册github账号<br><a href="https://github.com/" target="_blank" rel="noopener">Git官网</a></li>
<li>创建一个仓库，仓库名必须为 你的用户名.github.io</li>
<li>根据git教程，配置SSH key</li>
</ol>
<h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>  安装插件deploy-git<br>  npm install hexo-deployer-git –save</p>
<p>  打开Blog根目录下的_config.yml文件，这是博客的配置文件，修改与博客配置相关的各种信息。</p>
<p>  修改最后一行的配置</p>
<pre><code>deploy:
type: git
repo: https://github.com/ 你的用户名 /你的用户名.github.io.git
branch: master</code></pre><p>  部署时，将生成网页通过git方式上传到你对应的链接仓库中。</p>
<ul>
<li><p>hexo clean    //清除了你之前生成的东西</p>
</li>
<li><p>hexo generate  //生成静态文章，可以用 hexo g 缩写 </p>
</li>
<li><p>hexo deploy   //部署文章，可以用 hexo d 缩写 </p>
<p>然后访问 你的用户名.github.io</p>
</li>
</ul>
<h3 id="发布新文章"><a href="#发布新文章" class="headerlink" title="发布新文章"></a>发布新文章</h3><ol>
<li>使用命令行安装npm i hexo-deployer-git</li>
<li>hexo new post “title” 在blog\source_posts 的目录，下面生成一个 “title”.md 文件</li>
</ol>
<h3 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h3><p>  根目录下的 _config.yml ，是整个 hexo 框架的配置文件，可以在里面修改大部分的配置。<br>  <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">hexo官方配置地址</a></p>
<p>  <a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo主题下载</a><br>  也可以在你的 themes 文件夹下使用 Git clone 命令来下载:<br>  git clone <a href="https://github.com/blinkfox/hexo-theme-matery.git" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery.git</a></p>
<p>  在配置文件中修改theme的值<br>  theme: hexo-theme-matery<br>  文件名和主题文件名称一致</p>
<h3 id="新建默认页面"><a href="#新建默认页面" class="headerlink" title="新建默认页面"></a>新建默认页面</h3><ol>
<li><p>categories 用来展示所有分类的页面</p>
<ul>
<li>hexo new page “categories”</li>
</ul>
</li>
<li><p>tags 用来展示所有标签的页面</p>
<ul>
<li>hexo new page “tags”</li>
</ul>
</li>
<li><p>about 用来展示关于我和我的博客信息的页面</p>
<ul>
<li>hexo new page “about”</li>
</ul>
</li>
<li><p>about 用来展示关于我和我的博客信息的页面</p>
<ul>
<li>hexo new page “about”</li>
</ul>
</li>
<li><p>contact 用来展示留言板信息的页面</p>
<ul>
<li>hexo new page “contact”</li>
</ul>
</li>
<li><p>friends 用来展示友情连接信息的页面</p>
<ul>
<li>hexo new page “friends”</li>
<li>需要在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件</li>
</ul>
<p>[<br> {</p>
<pre><code>&quot;avatar&quot;: &quot;&quot;,
&quot;name&quot;: &quot;&quot;,
&quot;introduction&quot;: &quot;&quot;,
&quot;url&quot;: &quot;&quot;,
&quot;title&quot;: &quot;&quot;</code></pre><p> }<br>]</p>
</li>
<li><p>添加404页面</p>
<ul>
<li>在 /source/ 目录下新建一个404.md</li>
</ul>
</li>
</ol>
<pre><code>---
title: 404
date: 2019-04-17 19:41:10
type: &quot;404&quot;
layout: &quot;404&quot;
description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;
---</code></pre><ul>
<li>然后在 /themes/matery/layout/ 目录下新建一个 404.ejs 文件</li>
</ul>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    /* don&apos;t remove. */
    .about-cover {
        height: 75vh;
    }
&lt;/style&gt;
&lt;div class=&quot;bg-cover pd-header about-cover&quot;&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;row&quot;&gt;
            &lt;div class=&quot;col s10 offset-s1 m8 offset-m2 l8 offset-l2&quot;&gt;
                &lt;div class=&quot;brand&quot;&gt;
                    &lt;div class=&quot;title center-align&quot;&gt;
                        404
                    &lt;/div&gt;
                    &lt;div class=&quot;description center-align&quot;&gt;
                        &lt;%= page.description %&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    // 每天切换 banner 图.  Switch banner image every day.
    $(&apos;.bg-cover&apos;).css(&apos;background-image&apos;, &apos;url(/medias/banner/&apos; + new Date().getDay() + &apos;.jpg)&apos;);
&lt;/script&gt;</code></pre><h3 id="文章链接太长等问题"><a href="#文章链接太长等问题" class="headerlink" title="文章链接太长等问题"></a>文章链接太长等问题</h3><p>Hexo 官网固定链接的插件。</p>
<p>hexo-abbrlink ; Github ：<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></p>
<p>安装插件：</p>
<pre><code>npm install hexo-abbrlink --save</code></pre><p>在站点配置文件中修改 permalink ：</p>
<p>permalink: posts/:abbrlink.html</p>
<p>站点配置文件中配置插件：</p>
<p>#abbrlink config<br>abbrlink:<br>  alg: crc32  #support crc16(default) and crc32<br>  rep: hex    #support dec(default) and hex<br>链接效果：</p>
<ol>
<li>crc16 &amp; hex<br><a href="https://www.wshunli.com/posts/66c8.html" target="_blank" rel="noopener">https://www.wshunli.com/posts/66c8.html</a></li>
<li>crc16 &amp; dec<br><a href="https://www.wshunli.com/posts/65535.html" target="_blank" rel="noopener">https://www.wshunli.com/posts/65535.html</a></li>
<li>crc32 &amp; hex<br><a href="https://www.wshunli.com/posts/8ddf18fb.html" target="_blank" rel="noopener">https://www.wshunli.com/posts/8ddf18fb.html</a></li>
<li>crc32 &amp; dec<br><a href="https://www.wshunli.com/posts/1690090958.html" target="_blank" rel="noopener">https://www.wshunli.com/posts/1690090958.html</a></li>
</ol>
]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
